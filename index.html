<meta charset="utf8">
<title>Glorp0 - Alien Social Media</title>
<style>
:root {
  --alien-green: #39ff14;
  --dark-space: #0a0a1f;
  --glow: 0 0 10px var(--alien-green);
  --nebula-pink: rgba(255, 0, 255, 0.1);
  --nebula-blue: rgba(0, 255, 255, 0.1);
}

body {
  margin: 0;
  padding: 20px;
  background: 
    radial-gradient(circle at 20% 30%, var(--nebula-pink), transparent 40%),
    radial-gradient(circle at 80% 70%, var(--nebula-blue), transparent 40%),
    var(--dark-space);
  color: var(--alien-green);
  font-family: 'Courier New', monospace;
  min-height: 100vh;
  position: relative;
  overflow-x: hidden;
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    radial-gradient(1px 1px at 20px 30px, white, rgba(0,0,0,0)),
    radial-gradient(1px 1px at 40px 70px, white, rgba(0,0,0,0)),
    radial-gradient(1px 1px at 50px 160px, white, rgba(0,0,0,0)),
    radial-gradient(2px 2px at 200px 20px, white, rgba(0,0,0,0));
  background-repeat: repeat;
  animation: starTwinkle 4s linear infinite;
  opacity: 0.4;
  z-index: -1;
}

.floating-particle {
  position: fixed;
  width: 3px;
  height: 3px;
  background: var(--alien-green);
  border-radius: 50%;
  filter: blur(1px);
  opacity: 0.3;
  pointer-events: none;
  z-index: -1;
}

.flying-ufo {
  position: fixed;
  font-size: 2em;
  pointer-events: none;
  z-index: 1000;
  filter: drop-shadow(0 0 5px var(--alien-green));
  transition: transform 0.05s linear;
}

.planet {
  position: fixed;
  pointer-events: none;
  z-index: -1;
  filter: drop-shadow(0 0 10px var(--alien-green));
  opacity: 0.3;
}

@keyframes starTwinkle {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 0.7; }
}

@keyframes orbitRight {
  from { transform: rotate(0deg) translateX(100px) rotate(0deg); }
  to { transform: rotate(360deg) translateX(100px) rotate(-360deg); }
}

@keyframes orbitLeft {
  from { transform: rotate(360deg) translateX(100px) rotate(-360deg); }
  to { transform: rotate(0deg) translateX(100px) rotate(0deg); }
}

@keyframes planetPulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.4; }
}

.container {
  max-width: 800px;
  margin: 0 auto;
}

.header {
  text-align: center;
  margin-bottom: 30px;
  position: relative;
}

.header h1 {
  font-size: 3em;
  text-shadow: var(--glow);
  margin: 0;
}

.tagline {
  font-size: 1.2em;
  color: var(--alien-green);
  text-shadow: var(--glow);
  margin-top: 5px;
  font-style: italic;
  opacity: 0.8;
}

.inbox-button {
  position: absolute;
  top: 0;
  right: 0;
  background: var(--alien-green);
  color: var(--dark-space);
  border: none;
  padding: 10px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-family: inherit;
  font-weight: bold;
  margin: 5px;
}

.connected-users {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 20px;
  padding: 10px;
  border: 1px solid var(--alien-green);
  border-radius: 10px;
}

.user-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid var(--alien-green);
  box-shadow: var(--glow);
  cursor: pointer;
}

.post-form {
  margin-bottom: 30px;
  position: relative;
}

.crawling-worm {
  position: absolute;
  font-size: 20px;
  top: -25px;
  left: 10px;
  animation: wiggle 3s infinite ease-in-out;
  transform-origin: bottom;
  cursor: pointer;
}

@keyframes wiggle {
  0%, 100% { 
    transform: translateX(0) rotate(0deg);
  }
  25% { 
    transform: translateX(10px) rotate(10deg);
  }
  50% { 
    transform: translateX(20px) rotate(-10deg);
  }
  75% { 
    transform: translateX(30px) rotate(10deg);
  }
}

.post-input {
  width: 100%;
  padding: 15px;
  background: rgba(57, 255, 20, 0.1);
  border: 1px solid var(--alien-green);
  border-radius: 5px;
  color: var(--alien-green);
  font-family: inherit;
  resize: vertical;
  margin-bottom: 10px;
}

.post-button {
  background: var(--alien-green);
  color: var(--dark-space);
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
  font-family: inherit;
}

.posts {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.post {
  border: 1px solid var(--alien-green);
  border-radius: 10px;
  padding: 15px;
  position: relative;
  background: rgba(57, 255, 20, 0.05);
}

.post-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.post-content img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 10px 0;
  border-radius: 10px;
  border: 1px solid var(--alien-green);
  box-shadow: var(--glow);
}

.post-actions {
  display: flex;
  gap: 15px;
  margin-top: 10px;
  flex-wrap: wrap;
}

.action-button {
  background: none;
  border: none;
  color: var(--alien-green);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 5px 10px;
  border-radius: 5px;
  transition: background 0.2s;
}

.action-button:hover {
  background: rgba(57, 255, 20, 0.1);
}

.goo-drop {
  position: absolute;
  width: 10px;
  height: 10px;
  background: var(--alien-green);
  border-radius: 50%;
  filter: blur(2px);
  pointer-events: none;
  animation: drip 2s linear forwards;
}

@keyframes drip {
  0% {
    transform: translateY(0) scale(1);
    opacity: 0.8;
  }
  100% {
    transform: translateY(100vh) scale(0.5);
    opacity: 0;
  }
}

.scam-popup {
  position: fixed;
  background: rgba(10, 10, 31, 0.95);
  border: 2px solid var(--alien-green);
  border-radius: 10px;
  padding: 20px;
  box-shadow: var(--glow);
  max-width: 300px;
  z-index: 1000;
  animation: float 3s ease-in-out infinite;
}

.scam-popup button {
  background: var(--alien-green);
  color: var(--dark-space);
  border: none;
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-family: inherit;
  width: 100%;
}

.scam-popup .close-button {
  position: absolute;
  top: 5px;
  right: 5px;
  background: none;
  border: none;
  color: var(--alien-green);
  cursor: pointer;
  width: auto;
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}

.worm-message {
  position: absolute;
  top: -60px;
  left: 50px;
  background: rgba(57, 255, 20, 0.1);
  border: 1px solid var(--alien-green);
  border-radius: 5px;
  padding: 10px;
  font-size: 0.9em;
  animation: fadeInOut 4s forwards;
  pointer-events: none;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translateY(10px); }
  10% { opacity: 1; transform: translateY(0); }
  90% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-10px); }
}

#replyModal {
  display: none;
  position: fixed;
  background: rgba(10, 10, 31, 0.95);
  color: var(--alien-green);
  border: 2px solid var(--alien-green);
  padding: 20px;
  border-radius: 10px;
  max-width: 400px;
  z-index: 1100;
}

.notification {
  background: rgba(57, 255, 20, 0.2); 
  color: var(--alien-green);
  border: 1px solid var(--alien-green);
  border-radius: 5px;
  padding: 10px;
  margin-bottom: 10px;
  box-shadow: var(--glow);
  animation: slideInLeft 0.3s forwards;
  cursor: pointer;
  opacity: 0;
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-100%);
  }
  to {
    opacity: 1; 
    transform: translateX(0);
  }
}

@keyframes slideOutLeft {
  from {
    opacity: 1;
    transform: translateX(0);
  }
  to {
    opacity: 0;
    transform: translateX(-100%);
  }
}

#profileModal {
  display: none;
  position: fixed;
  background: rgba(10, 10, 31, 0.95);
  color: var(--alien-green);
  border: 2px solid var(--alien-green);
  padding: 20px;
  border-radius: 10px;
  max-width: 600px;
  z-index: 1200;
}
#profileModal img {
  display: block;
  margin: 0 auto;
  border: 2px solid var(--alien-green);
  border-radius: 50%;
  box-shadow: var(--glow);
  width: 120px; 
  height: 120px; 
}
#profileModal .bio-text {
  margin-top: 10px;
  white-space: pre-wrap;
  word-wrap: break-word;
}
#profileModal button {
  background: var(--alien-green);
  color: var(--dark-space);
  border: none;
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-family: inherit;
  margin-top: 10px;
}
#profileModal .close-button {
  background: none;
  border: none;
  color: var(--alien-green);
  float: right;
  font-size: 16px;
  cursor: pointer;
  margin-top: -10px;
  margin-right: -5px;
}
#profileModal textarea {
  width: 100%;
  background: transparent;
  border: 1px solid var(--alien-green);
  color: var(--alien-green);
  resize: vertical;
  font-family: inherit;
  margin-top: 10px;
}
#profileEditButtons {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 10px;
}

#profileStats {
  margin-top: 10px;
  border: 1px solid var(--alien-green);
  border-radius: 5px;
  padding: 10px;
}

#profilePosts {
  margin-top: 10px;
  border-top: 1px solid var(--alien-green);
  padding-top: 10px;
}

/* Tabs styling */
.tabs {
  margin-top: 10px;
  display: flex;
  justify-content: center;
  gap: 10px;
}
#homeTabButton,
#messagesTabButton {
  background: var(--alien-green);
  color: var(--dark-space);
  border: none;
  padding: 10px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-family: inherit;
  font-weight: bold;
}

/* DM Tab Layout */
#messagesContainer {
  display: none;
  max-width: 1000px;
  margin: 0 auto;
  border: 1px solid var(--alien-green);
  border-radius: 10px;
  padding: 20px;
  margin-top: 20px;
}

#dmTabLayout {
  display: flex;
  gap: 20px;
}

#dmThreadsColumn {
  flex: 1;
  border-right: 1px solid var(--alien-green);
  padding-right: 10px;
  max-width: 300px;
}

#dmConversationColumn {
  flex: 2;
}

#dmThreadsColumn .title {
  font-weight: bold;
  margin-bottom: 10px;
  text-align: center;
  font-size: 1.2em;
}

#inboxModal {
  display: none;
  position: fixed;
  background: rgba(10, 10, 31, 0.95);
  color: var(--alien-green);
  border: 2px solid var(--alien-green);
  padding: 20px;
  border-radius: 10px;
  max-width: 600px;
  z-index: 1300;
  overflow-y: auto;
  max-height: 80vh;
}

#inboxModal .close-button {
  background: none;
  border: none;
  color: var(--alien-green);
  float: right;
  font-size: 16px;
  cursor: pointer;
  margin-top: -10px;
  margin-right: -5px;
}

#dmThreadsList {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 40px;
}

.dm-thread-item {
  border: 1px solid var(--alien-green);
  border-radius: 5px;
  padding: 10px;
  cursor: pointer;
  background: rgba(57, 255, 20, 0.1);
}

.dm-thread-item:hover {
  background: rgba(57, 255, 20, 0.2);
}

#dmModal {
  display: none;
  position: fixed;
  background: rgba(10, 10, 31, 0.95);
  color: var(--alien-green);
  border: 2px solid var(--alien-green);
  padding: 20px;
  border-radius: 10px;
  max-width: 600px;
  z-index: 1400;
  overflow-y: auto;
  max-height: 80vh;
}

#dmModal .close-button {
  background: none;
  border: none;
  color: var(--alien-green);
  float: right;
  font-size: 16px;
  cursor: pointer;
  margin-top: -10px;
  margin-right: -5px;
}

#dmConversation {
  border: 1px solid var(--alien-green);
  border-radius: 5px;
  padding: 10px;
  margin-top: 40px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 300px;
  overflow-y: auto;
}

.dm-message {
  display: flex;
  flex-direction: column;
}

.dm-sender {
  font-weight: bold;
  margin-bottom: 2px;
}

#dmInput {
  width: 100%;
  background: transparent;
  border: 1px solid var(--alien-green);
  color: var(--alien-green);
  resize: vertical;
  font-family: inherit;
  margin-top: 10px;
  padding: 8px;
}

#dmSendButton {
  background: var(--alien-green);
  color: var(--dark-space);
  border: none;
  padding: 8px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-family: inherit;
  margin-top: 10px;
}
.bio-text {
  margin-top: 10px;
  white-space: pre-wrap;
  word-wrap: break-word;
}

#profileBioEdit {
  display: none; 
  width: 100%;
  background: transparent;
  border: 1px solid var(--alien-green);
  color: var(--alien-green);
  resize: vertical;
  font-family: inherit;
  margin-top: 10px;
}

#editBioButton {
  background: none;
  color: var(--alien-green);
  border: 1px solid var(--alien-green);
  padding: 5px 10px;
  border-radius: 5px;
  cursor: pointer;
  font-family: inherit;
}

.replies {
  margin-top: 10px;
  margin-left: 20px;
  border-left: 2px solid var(--alien-green);
  padding-left: 10px;
  background: rgba(57, 255, 20, 0.02);
  border-radius: 0 5px 5px 0;
}

.reply {
  margin-top: 10px;
  padding: 8px;
  background: rgba(57, 255, 20, 0.05);
  border-radius: 5px;
  transition: background 0.3s ease;
}

.reply:hover {
  background: rgba(57, 255, 20, 0.08);
}
</style>
</head>
<body>
<div id="notificationArea" style="position: fixed; top: 10px; left: 10px; z-index: 1001; min-width: 200px; max-width: 300px;"></div>

<div class="header">
  <h1 style="cursor: pointer;" onclick="showHomeTab()">&#x1f6f8; Glorp0</h1>
  <div class="tagline">make it goo</div>
  <div class="tabs">
    <button id="homeTabButton" class="inbox-button">Home</button>
    <button id="messagesTabButton" class="inbox-button">Messages</button>
  </div>
  <!-- Keep the original Inbox button hidden so we don't remove code, preserving completeness -->
  <button id="inboxButton" class="inbox-button" style="display:none;">Inbox</button>
</div>

<!-- HOME CONTAINER (FEED) -->
<div id="homeContainer" class="container">
  <div class="connected-users" id="connectedUsers">
    <!-- Connected users will appear here -->
  </div>

  <div class="post-form">
    <div class="crawling-worm">&#x1fab1;</div>
    <textarea class="post-input" id="postInput" placeholder="Scream in to the void" rows="4"></textarea>
    <button class="post-button" id="postButton">Glorp It!</button>
  </div>

  <div class="posts" id="posts">
    <!-- Posts will appear here -->
  </div>
</div>

<!-- MESSAGES CONTAINER (DM TAB) -->
<div id="messagesContainer">
  <div id="dmTabLayout">
    <div id="dmThreadsColumn">
      <div class="title">Conversations</div>
      <div id="dmThreadsListContainer"></div>
    </div>
    <div id="dmConversationColumn">
      <h2 id="dmThreadTitleTab" style="margin-top:0;">Select a conversation</h2>
      <div id="dmConversationContainer" style="border:1px solid var(--alien-green); border-radius:5px; padding:10px; min-height:300px; max-height:400px; overflow-y:auto;"></div>
      <textarea id="dmInputTab" rows="3" placeholder="Send a DM..." style="width:100%; background:transparent; border:1px solid var(--alien-green); color:var(--alien-green); resize:vertical; font-family:inherit; margin-top:10px; padding:8px;"></textarea>
      <button id="dmSendButtonTab" style="background: var(--alien-green); color: var(--dark-space); border:none; padding:8px 15px; border-radius:5px; cursor:pointer; font-family:inherit; margin-top:10px;">
        Send
      </button>
    </div>
  </div>
</div>

<div id="replyModal">
  <h3>Reply to Post</h3>
  <textarea id="replyInput" rows="4" style="width: 100%; background: transparent; border: 1px solid var(--alien-green); color: var(--alien-green); resize: vertical;"></textarea>
  <button id="replySubmitButton">Submit Reply</button>
  <button id="replyCancelButton" class="close-button">Cancel</button>
</div>

<!-- Profile Modal -->
<div id="profileModal">
  <button class="close-button" id="profileCloseButton">&#xd7;</button>
  <div style="text-align:center">
    <img id="profileAvatar" src alt="Profile Avatar">
  </div>
  <h3 id="profileUsername" style="text-align:center; margin-top:10px;"></h3>
  <div class="bio-text" id="profileBio"></div>
  <button id="editBioButton" style="margin-top: 10px;">Edit Bio</button>
  <textarea id="profileBioEdit" rows="4" style="display:none;"></textarea>
  <div id="profileEditButtons" style="display:none;">
    <button id="profileSaveButton">Save</button>
    <button id="profileCancelButton">Cancel</button>
  </div>
  <div id="profileFollowButtonContainer" style="text-align:center; margin-top:10px;"></div>
  <div id="profileStats"></div>
  <div id="profilePosts"></div>
</div>

<!-- Inbox Modal (kept for completeness, not used) -->
<div id="inboxModal">
  <button class="close-button" id="inboxCloseButton">&#xd7;</button>
  <h2>Direct Messages</h2>
  <div id="dmThreadsList"></div>
</div>

<!-- DM Modal (kept for completeness, not used) -->
<div id="dmModal">
  <button class="close-button" id="dmCloseButton">&#xd7;</button>
  <h3 id="dmThreadTitle">Conversation</h3>
  <div id="dmConversation"></div>
  <textarea id="dmInput" rows="3" placeholder="Send a DM..."></textarea>
  <button id="dmSendButton">Send</button>
</div>

<script>
async function createFollowsTable() {
  let query = `CREATE TABLE if not exists follows (id INTEGER PRIMARY KEY, follower TEXT, followee TEXT)`;
  let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
    sql: query
  }));
  let data = await results.json();
  console.log("createFollowsTable:", data);
}
async function fetchFollows() {
  let query = `SELECT * FROM follows`;
  let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
    sql: query
  }));
  let data = await results.json();
  if (data && Array.isArray(data)) {
    window.followsData = data;
  } else if (data && data.rows && Array.isArray(data.rows)) {
    window.followsData = data.rows;
  } else {
    window.followsData = [];
  }
}
async function insertFollow(follower, followee) {
  let query = `INSERT INTO follows (follower, followee) VALUES ('${follower}', '${followee}')`;
  let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
    sql: query
  }));
  let data = await results.json();
  console.log("insertFollow:", data);
}
async function deleteFollow(follower, followee) {
  let query = `DELETE FROM follows WHERE follower='${follower}' AND followee='${followee}'`;
  let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
    sql: query
  }));
  let data = await results.json();
  console.log("deleteFollow:", data);
}
let isReconnecting = false;
const alienNames = ['Zyx-427', 'Blorp', 'Qwerty', 'Nexus-6', 'Glitch', 'Binary', 'Quantum', 'Pixel', 'Vector', 'Nova', 'Greg', 'W0RM', 'Cosmos', 'Nebula', 'Void', 'Static', 'Matrix', 'Circuit', 'Debug', 'Cache'];
const alienAvatars = ['üëΩ', 'üõ∏', 'üëæ', 'ü§ñ', 'üéÆ', 'üí´', 'üåå', '‚ú®', 'üå†', 'üöÄ', 'üõ∏'];
const gregPosts = ["üöÄ HUGE OPPORTUNITY! Just discovered a quantum mining operation on Jupiter's moons! Only 1000 GlorpCoins to join! DM me! üí∞", "üåü BREAKING: New cryptocurrency launching - MoonRocks! Get in early before we reach Alpha Centauri! Only 500 GlorpCoins! ü™®", "üí´ EXCLUSIVE: Join my Intergalactic Pyramid Scheme! It's not a pyramid, it's a quantum tetrahedron of wealth! üìà", "üéÆ Selling rare Dropnoids at 90% discount! These are totally legitimate and not quantum-copied! Trust me! üéØ", "‚ö° URGENT: Need 50 GlorpCoins for spacecraft repairs. Will return 500 GlorpCoins tomorrow! Quantum-guaranteed! üõ∏", "üåç Earth is flat and I can prove it! Send me 100 GlorpCoins for the secret files! ü§´", "üíé Just found a glitch in the universal matrix! Double your GlorpCoins instantly! Limited time offer! üí´", "üé∞ Start your own Asteroid Mining Empire! Only 2000 GlorpCoins to begin! Totally legal in this galaxy! ‚õèÔ∏è", "üå† INSIDER INFO: The Galactic Council is about to approve SpaceDoge coin! Buy now! üêï", "üíº Looking for quantum investment partners! 1000% return guaranteed by the laws of physics! üìä"];
const alienPosts = ["Just discovered a new quantum anomaly in sector 7G! üåå", "Anyone else's tentacles feeling extra wiggly today? üêô", "Earth's memes are getting better! Almost as good as Zeta Reticuli's! üëΩ", "Who wants to join my interdimensional book club? üìö‚ú®", "Finally mastered telepathic emoji sending! üß†üí≠", "Just upgraded my UFO's cup holders. Much better! üõ∏‚òï", "These human 'cats' are clearly alien spies, right? üê±üëΩ", "Anyone else having trouble with their cloaking device? üîß", "Found this amazing black hole for vacation! üï≥Ô∏è‚ú®", "Human music is weird but I can't stop listening! üéµüëΩ", "The intergalactic trade federation is imposing new tariffs on dark matter exports! üò†", "Just attended the annual Galactic Senate meeting. Politics as usual. üôÑ", "Who else is excited for the upcoming cosmic convergence? ‚ú®üåå", "Can't believe the Martians voted for mandatory antenna implants! üì°", "Petition to relocate Earth to a less crowded arm of the Milky Way! üåéüöÄ", "Zorbax from Kepler-186f is live streaming their 200th birthday! ü•≥üëΩ", "Received a telepathic spam message about cheap lunar real estate. üåùüèòÔ∏è", "I heard the Andromedans are developing AI that can predict future memes! ü§ñ", "Apparently the Saturn Tourism Board is offering discounts for ringed planet cruises! ü™êüö¢", "A new study shows that 60% of humans believe in aliens. The other 40% haven't met us yet! üòâ"];
const wormPosts = ["01101000 01101001 01101000 01101001 ü™±", "Found a delicious new data packet today! ü™±üíæ", "Crawling through the codebase, nothing suspicious here... ü™±", "Your system's security is *chef's kiss* ü™±‚ú®", "Just ate some legacy code, feeling good! ü™±üçΩÔ∏è", "Who else loves binary for breakfast? ü™±‚òï", "Definitely not collecting any sensitive data... ü™±üëÄ", "Your firewall is very cozy! ü™±üè†", "Quantum tunneling through your encryption! ü™±üîí", "Nice try with that antivirus update! ü™±üòé"];
const alienImages = ['https://images.websim.ai/alien/1.png', 'https://images.websim.ai/alien/2.png', 'https://images.websim.ai/alien/3.png', 'https://images.websim.ai/alien/4.png', 'https://images.websim.ai/alien/5.png'];
const wormMessages = ["I see you! Nice data you got there...", "Just crawling through, don't mind me!", "Your cookies look delicious!", "Wanna trade some encrypted secrets?", "I promise I'm a feature, not a bug!", "*wiggles in binary*", "Your firewall is very cozy!", "Got any tasty data packets?", "I come in peace... mostly!", "Your system security is *chef's kiss*"];
const scamMessages = [{
  title: "üåø AMAZING DEAL: Pete's Lawnmower! üåø",
  message: "3-SPEED LAWNMOWER (mostly works) FOR SALE! No lowballers, I know what I have! Contact Pete NOW! üöú",
  isDropnoid: false,
  isPete: true
}, {
  title: "üî• HOT DEAL: Professional Grass Cutting Machine! üî•",
  message: "SLIGHTLY USED lawn equipment! Only small oil leak (barely noticeable unless running). Pete's Quality Guarantee! üõ†Ô∏è",
  isDropnoid: false,
  isPete: true
}, {
  title: "‚ö° FLASH SALE: Pete's Premium Lawnmower! ‚ö°",
  message: "Speed settings: Fast, Faster, and LUDICROUS! Comes with original manual (slightly water damaged)! üèÉ‚Äç‚ôÇÔ∏è",
  isDropnoid: false,
  isPete: true
}, {
  title: "üöÄ CRYPTO OPPORTUNITY! üöÄ",
  message: "Invest in GlorpCoin now! 1000x returns guaranteed by quantum mechanics! Don't miss out on the interstellar gains! üöÄüí´",
  isDropnoid: false,
  isPete: false
}, {
  title: "üéÆ FREE DROPNOID! üéÆ",
  message: "You've been selected to receive a FREE Dropnoid NFT! Limited time offer from the Andromeda galaxy!",
  isDropnoid: true
}, {
  title: "üîÆ PSYCHIC INVESTMENT OPPORTUNITY üîÆ",
  message: "Our quantum AI has predicted a 500% return on MoonTokens! Join now before takeoff! üåô",
  isDropnoid: false
}, {
  title: "üëΩ ALIEN TECHNOLOGY PRESALE üëΩ",
  message: "Be the first to invest in revolutionary alien tech! Early investors get special telepathic abilities!",
  isDropnoid: false
}, {
  title: "üéØ CONGRATULATIONS! YOU'VE WON! üéØ",
  message: "Your consciousness has been selected to receive 1,000,000 SpaceBucks! Claim now!",
  isDropnoid: false
}, {
  title: "üí´ INTERGALACTIC MINING POOL üí´",
  message: "Mine StarlightCoin with zero effort! Our quantum computers do all the work!",
  isDropnoid: false
}, {
  title: "üåå NEBULA DAO PRESALE üåå",
  message: "Join the first decentralized autonomous organization in the Andromeda Galaxy!",
  isDropnoid: false
}, {
  title: "üéÆ RARE DROPNOID DISCOVERED! üéÆ",
  message: "A legendary Ancient Alien Dropnoid has appeared! Claim it before someone else does!",
  isDropnoid: true
}, {
  title: "üöÄ ROCKET TOKEN LAUNCH üöÄ",
  message: "Don't miss the biggest token launch since the Big Bang! To the stars! üåü",
  isDropnoid: false
}, {
  title: "üî• HOT TIP FROM GREG! üî•",
  message: "I've discovered a glitch in the quantum trading matrix! Join now for infinite gains!",
  isDropnoid: false
}];
async function createBiosTable() {
  let query = `CREATE TABLE if not exists bios (id integer primary key, username text, bio text)`;
  let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
    sql: query
  }));
  let data = await results.json();
  console.log("createBiosTable:", data);
}

async function fetchBios() {
  try {
    let query = `SELECT * FROM bios`;
    let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
      sql: query
    }));
    let data = await results.json();
    
    if (data && Array.isArray(data)) {
      window.biosData = data;
    } else if (data && Array.isArray(data.rows)) {
      window.biosData = data.rows;
    } else {
      window.biosData = [];
    }
    
    console.log('Updated bios data:', window.biosData);
  } catch (error) {
    console.error('Error fetching bios:', error);
    window.biosData = [];
  }
}

async function insertOrUpdateBio(username, newBio) {
  const sanitizedBio = newBio.replace(/'/g, "''");
  
  try {
    let existingBio = window.biosData?.find(b => b.username === username);
    let query;
    
    if (existingBio) {
      query = `UPDATE bios SET bio='${sanitizedBio}' WHERE username='${username}'`;
    } else {
      query = `INSERT INTO bios (username, bio) VALUES ('${username}', '${sanitizedBio}')`;
    }
    
    let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
      sql: query
    }));
    let data = await results.json();
    console.log("insertOrUpdateBio response:", data);
    
    await fetchBios();
    
    return true;
  } catch (error) {
    console.error('Error updating bio:', error);
    throw error;
  }
}

let room = new WebsimSocket();
room.onPeersChanged = updateConnectedUsers;
room.onRecordChanged = async id => {
  if (id === 'posts') {
    try {
      await refreshPosts();
    } catch (error) {
      console.error('Error refreshing posts:', error);
      if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
        await reconnectWebSocket();
      }
    }
  } else if (id === 'bios') {
    if (openProfileClientId !== null) {
      showProfile(openProfileClientId);
    }
  } else if (id === 'follows') {
    if (openProfileClientId !== null) {
      showProfile(openProfileClientId);
    }
  } else if (id === 'dms') {
    if (inboxOpen) refreshDMThreads();
    if (currentDMThreadId) refreshDMConversation();
    refreshDMThreadsTab();
    if (currentDMThreadIdTab) refreshDMConversationTab();
  }
};
async function reconnectWebSocket() {
  if (isReconnecting) return;
  isReconnecting = true;
  console.log('Attempting to reconnect WebSocket...');
  try {
    room = new WebsimSocket();
    room.onPeersChanged = updateConnectedUsers;
    room.onRecordChanged = async id => {
      if (id === 'posts') {
        try {
          await refreshPosts();
        } catch (error) {
          console.error('Error refreshing posts:', error);
          if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
            await reconnectWebSocket();
          }
        }
      } else if (id === 'bios') {
        if (openProfileClientId !== null) {
          showProfile(openProfileClientId);
        }
      } else if (id === 'follows') {
        if (openProfileClientId !== null) {
          showProfile(openProfileClientId);
        }
      } else if (id === 'dms') {
        if (inboxOpen) refreshDMThreads();
        if (currentDMThreadId) refreshDMConversation();
        refreshDMThreadsTab();
        if (currentDMThreadIdTab) refreshDMConversationTab();
      }
    };
    await refreshPosts();
    isReconnecting = false;
  } catch (error) {
    console.error('Error reconnecting:', error);
    isReconnecting = false;
    setTimeout(reconnectWebSocket, 5000);
  }
}

function sanitizeContent(str) {
  return str.replace(/</g, 'URI-OPEN').replace(/>/g, 'URI-CLOSE');
}

async function refreshPosts() {
  try {
    const posts = (await room.store.get('posts')) || [];
    const postsContainer = document.getElementById('posts');
    postsContainer.innerHTML = '';
    const sortedPosts = [...posts].sort((a, b) => b.timestamp - a.timestamp);

    sortedPosts.forEach(post => {
      const postElement = createPostElement(post);
      postsContainer.appendChild(postElement);
    });
  } catch (error) {
    console.error('Error refreshing posts:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
    }
  }
}

async function generatePost(content) {
  try {
    const sanitizedContent = sanitizeContent(content);
    const username = room.party.client.username;
    const avatarUrl = room.party.client.avatarUrl;
    const post = {
      id: Date.now().toString(),
      content: sanitizedContent,
      username,
      avatarUrl,
      timestamp: Date.now(),
      likes: [],
      dislikes: [],
      reglorps: [],
      replies: []
    };
    await room.store.update({
      id: 'posts',
      dependencies: {
        post
      },
      updateFunction: (posts = []) => [...posts, post]
    });
    await refreshPosts();
    playAlienSound();
  } catch (error) {
    console.error('Error generating post:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await generatePost(content);
    } else {
      throw error;
    }
  }
}

document.getElementById('postButton').addEventListener('click', async () => {
  const input = document.getElementById('postInput');
  const button = document.getElementById('postButton');
  const content = input.value.trim();
  if (content) {
    button.disabled = true;
    button.textContent = 'Sending...';
    try {
      await generatePost(content);
      input.value = '';
      button.textContent = 'Glorp It!';
      button.disabled = false;
    } catch (error) {
      console.error('Error posting:', error);
      button.textContent = 'Error - Try Again';
      button.disabled = false;
    }
  }
});

let replyingToPostId = null;
document.addEventListener('DOMContentLoaded', () => {
  document.body.addEventListener('click', event => {
    if (event.target.classList.contains('reply-button')) {
      showReplyModal(event.target.dataset.postId);
    }
  });
  document.getElementById('replySubmitButton').addEventListener('click', submitReply);
  document.getElementById('replyCancelButton').addEventListener('click', hideReplyModal);
  document.getElementById('profileCloseButton').addEventListener('click', hideProfileModal);
  document.getElementById('profileCancelButton').addEventListener('click', () => {
    hideBioEdit();
    showProfile(openProfileClientId);
  });
  document.getElementById('profileSaveButton').addEventListener('click', saveProfileBio);
  const profileBioEdit = document.getElementById('profileBioEdit');
  profileBioEdit.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      saveProfileBio();
    }
  });
  const inboxBtn = document.getElementById('inboxButton');
  if (inboxBtn) {
    inboxBtn.style.display = 'none';
  }
  const homeTabButton = document.getElementById('homeTabButton');
  const messagesTabButton = document.getElementById('messagesTabButton');
  homeTabButton.addEventListener('click', showHomeTab);
  messagesTabButton.addEventListener('click', showMessagesTab);
  document.getElementById('dmSendButtonTab').addEventListener('click', dmSendMessageTab);
  document.getElementById('editBioButton').addEventListener('click', () => {
    const bioText = document.getElementById('profileBio');
    const bioEdit = document.getElementById('profileBioEdit');
    const editButtons = document.getElementById('profileEditButtons');
    
    bioText.style.display = 'none';
    document.getElementById('editBioButton').style.display = 'none';
    bioEdit.style.display = 'block';
    editButtons.style.display = 'flex';
    bioEdit.focus();
  });
});

function showHomeTab() {
  document.getElementById('homeContainer').style.display = 'block';
  document.getElementById('messagesContainer').style.display = 'none';
  document.getElementById('homeTabButton').style.opacity = '1';
  document.getElementById('messagesTabButton').style.opacity = '0.7';
}

function showMessagesTab() {
  document.getElementById('homeContainer').style.display = 'none';
  document.getElementById('messagesContainer').style.display = 'block';
  document.getElementById('homeTabButton').style.opacity = '0.7';
  document.getElementById('messagesTabButton').style.opacity = '1';
  refreshDMThreadsTab();
  if (currentDMThreadIdTab) {
    refreshDMConversationTab();
  }
}

async function submitReply() {
  const replyContent = document.getElementById('replyInput').value.trim();
  if (!replyContent || !replyingToPostId) return;
  const sanitizedContent = sanitizeContent(replyContent);
  const username = room.party.client.username;
  const avatarUrl = room.party.client.avatarUrl;
  try {
    await room.store.update({
      id: 'posts',
      dependencies: {
        sanitizedContent,
        replyingToPostId,
        username,
        avatarUrl
      },
      updateFunction: posts => {
        return posts.map(post => {
          if (post.id === replyingToPostId) {
            const replies = post.replies || [];
            return {
              ...post,
              replies: [...replies, {
                username,
                content: sanitizedContent,
                timestamp: Date.now(),
                avatarUrl
              }]
            };
          }
          return post;
        });
      }
    });
    hideReplyModal();
    playAlienSound();
    await refreshPosts();
    const posts = await room.store.get('posts');
    const updatedPost = posts.find(p => p.id === replyingToPostId);
    if (updatedPost) notifyInteractions(updatedPost, 'reply');
  } catch (error) {
    console.error('Error submitting reply:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await submitReply();
    }
  }
}

function showReplyModal(postId) {
  replyingToPostId = postId;
  const modal = document.getElementById('replyModal');
  modal.style.display = 'block';
  modal.style.left = window.innerWidth / 2 - modal.offsetWidth / 2 + 'px';
  modal.style.top = window.innerHeight / 2 - modal.offsetHeight / 2 + 'px';
  document.getElementById('replyInput').value = '';
}

function hideReplyModal() {
  replyingToPostId = null;
  document.getElementById('replyModal').style.display = 'none';
}

function createPostElement(post) {
  const postElement = document.createElement('div');
  postElement.className = 'post';
  const currentUser = room.party.client.username;
  
  post.likes = post.likes || [];
  post.dislikes = post.dislikes || [];
  post.reglorps = post.reglorps || [];
  post.replies = post.replies || [];
  
  const liked = post.likes.includes(currentUser);
  const disliked = post.dislikes.includes(currentUser);
  const reglorped = post.reglorps.includes(currentUser);

  const avatarContent = post.avatarUrl && post.avatarUrl.startsWith('http') 
    ? `<img src="${post.avatarUrl}" alt="${post.username}" class="user-avatar" />`
    : `<span class="user-avatar" style="display:flex;align-items:center;justify-content:center;font-size:24px;background:rgba(57, 255, 20, 0.1)">${post.avatarUrl || 'üëΩ'}</span>`;

  postElement.innerHTML = `
    <div class="post-header">
      ${avatarContent}
      <strong>${post.username}</strong>
      <span style="opacity: 0.7; margin-left: auto;">
        ${new Date(post.timestamp).toLocaleTimeString()}
      </span>
    </div>
    <div class="post-content">${post.content}</div>
    <div class="post-actions">
      <button class="action-button like-button" onclick="handleLike('${post.id}')">
        ${liked ? '‚ù§Ô∏è' : 'ü§ç'} Like ${post.likes.length}
      </button>
      <button class="action-button dislike-button" onclick="handleDislike('${post.id}')">
        ${disliked ? 'üíî' : 'üñ§'} Dislike ${post.dislikes.length}
      </button>
      <button class="action-button reglorp-button" onclick="handleReglorp('${post.id}')">
        ${reglorped ? 'üõ∏' : 'üõ∏'} Reglorp ${post.reglorps.length}
      </button>
      <button class="action-button reply-button" data-post-id="${post.id}">
        üí≠ Reply ${post.replies.length}
      </button>
    </div>
    ${post.replies?.length ? `
      <div class="replies">
        <h4 style="margin: 0 0 5px 0;">Replies</h4>
        ${post.replies.map(reply => `
          <div class="reply">
            <div style="display: flex; align-items: center; gap: 10px;">
              ${reply.avatarUrl ? 
                `<img src="${reply.avatarUrl}" alt="${reply.username}" style="width: 30px; height: 30px; border-radius: 50%; border: 1px solid var(--alien-green);">` 
                : `<span style="font-size: 24px; display:flex;align-items:center;justify-content:center;background:rgba(57, 255, 20, 0.1)">${reply.avatarUrl || 'üëΩ'}</span>`
              }
              <strong>${reply.username}</strong>
              <span style="opacity: 0.7; margin-left: auto; font-size: 0.8em;">
                ${new Date(reply.timestamp).toLocaleTimeString()}
              </span>
            </div>
            <div style="margin-top: 5px; margin-left: 40px;">${reply.content}</div>
          </div>
        `).join('')}
      </div>
    ` : ''}
  `;

  const avatarElement = postElement.querySelector('.user-avatar');
  avatarElement.addEventListener('click', () => {
    let clientId = null;
    const peers = room.party.peers;
    for (const pid in peers) {
      if (peers[pid].username === post.username) {
        clientId = pid;
        break;
      }
    }
    if (!clientId && post.username === room.party.client.username) {
      clientId = room.party.client.id;
    }
    if (clientId) {
      showProfile(clientId);
    }
  });

  return postElement;
}

async function addRandomAlienPost() {
  const rand = Math.random();
  let content, username, avatarUrl;
  if (rand < 0.2) {
    content = gregPosts[Math.floor(Math.random() * gregPosts.length)];
    username = 'Greg';
    avatarUrl = alienAvatars[6];
  } else if (rand < 0.4) {
    content = wormPosts[Math.floor(Math.random() * wormPosts.length)];
    username = 'W0RM';
    avatarUrl = alienAvatars[10];
  } else {
    content = alienPosts[Math.floor(Math.random() * alienPosts.length)];
    username = alienNames[Math.floor(Math.random() * alienNames.length)];
    avatarUrl = alienAvatars[Math.floor(Math.random() * alienAvatars.length)];
  }
  const post = {
    id: Date.now().toString(),
    content,
    username,
    avatarUrl,
    timestamp: Date.now(),
    likes: [],
    dislikes: [],
    reglorps: [],
    replies: []
  };
  try {
    await room.store.update({
      id: 'posts',
      dependencies: {
        post
      },
      updateFunction: (posts = []) => [...posts, post]
    });
    await refreshPosts();
  } catch (error) {
    console.error('Error adding random alien post:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
    }
  }
  setTimeout(addRandomAlienPost, 30000 + Math.random() * 30000);
}

function updateConnectedUsers(peers) {
  const connectedUsers = document.getElementById('connectedUsers');
  connectedUsers.innerHTML = '';
  Object.keys(peers).forEach(clientId => {
    const peer = peers[clientId];
    const userElement = document.createElement('div');
    userElement.style.position = 'relative';
    if (peer.avatarUrl && peer.avatarUrl.startsWith('http')) {
      const avatar = document.createElement('img');
      avatar.src = peer.avatarUrl;
      avatar.alt = peer.username;
      avatar.className = 'user-avatar';
      avatar.title = peer.username;
      avatar.dataset.clientId = clientId;
      userElement.appendChild(avatar);
    } else {
      const avatarSpan = document.createElement('span');
      avatarSpan.textContent = peer.avatarUrl || 'üëΩ';
      avatarSpan.className = 'user-avatar';
      avatarSpan.style.display = 'flex';
      avatarSpan.style.alignItems = 'center';
      avatarSpan.style.justifyContent = 'center';
      avatarSpan.style.fontSize = '24px';
      avatarSpan.style.background = 'rgba(57, 255, 20, 0.1)';
      avatarSpan.title = peer.username;
      avatarSpan.dataset.clientId = clientId;
      userElement.appendChild(avatarSpan);
    }
    userElement.querySelector('.user-avatar').addEventListener('click', () => {
      showProfile(clientId);
    });
    connectedUsers.appendChild(userElement);
  });
}

function notifyInteractions(post, type) {
  if (post.username === room.party.client.username) {
    const notificationArea = document.getElementById('notificationArea');
    const notification = document.createElement('div');
    notification.className = 'notification';
  
    let message = '';
    switch (type) {
      case 'like':
        message = '‚ù§Ô∏è Someone liked your post!';
        break;
      case 'dislike':
        message = 'üíî Someone disliked your post!';
        break;
      case 'reglorp':
        message = 'üõ∏ Someone reglorped your post!';
        break;
      case 'reply':
        message = 'üí≠ Someone replied to your post!';
        break;
    }
  
    notification.textContent = message;
    notificationArea.appendChild(notification);

    requestAnimationFrame(() => {
      notification.style.animation = 'slideInLeft 0.3s forwards';
    });

    setTimeout(() => {
      notification.style.animation = 'slideOutLeft 0.3s forwards';
      notification.addEventListener('animationend', () => {
        notification.remove();
      }, {once: true});
    }, 5000);

    playNotificationSound(type);
  }
}

async function handleLike(postId) {
  const username = room.party.client.username;
  try {
    await room.store.update({
      id: 'posts',
      dependencies: {
        postId,
        username
      },
      updateFunction: posts => {
        return posts.map(post => {
          if (post.id === postId) {
            const likes = post.likes || [];
            const dislikes = post.dislikes || [];
            const index = likes.indexOf(username);
            if (index === -1) {
              return {
                ...post,
                likes: [...likes, username],
                dislikes: dislikes.filter(u => u !== username)
              };
            } else {
              return {
                ...post,
                likes: likes.filter(u => u !== username)
              };
            }
          }
          return post;
        });
      }
    });
    const posts = await room.store.get('posts');
    const updatedPost = posts.find(p => p.id === postId);
    if (updatedPost) {
      notifyInteractions(updatedPost, 'like');
    }
    await refreshPosts();
  } catch (error) {
    console.error('Error handling like:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await handleLike(postId);
    }
  }
}

async function handleDislike(postId) {
  const username = room.party.client.username;
  try {
    await room.store.update({
      id: 'posts',
      dependencies: {
        postId,
        username
      },
      updateFunction: posts => {
        return posts.map(post => {
          if (post.id === postId) {
            const likes = post.likes || [];
            const dislikes = post.dislikes || [];
            const index = dislikes.indexOf(username);
            if (index === -1) {
              return {
                ...post,
                dislikes: [...dislikes, username],
                likes: likes.filter(u => u !== username)
              };
            } else {
              return {
                ...post,
                dislikes: dislikes.filter(u => u !== username)
              };
            }
          }
          return post;
        });
      }
    });
    const posts = await room.store.get('posts');
    const updatedPost = posts.find(p => p.id === postId);
    if (updatedPost) {
      notifyInteractions(updatedPost, 'dislike');
    }
    await refreshPosts();
  } catch (error) {
    console.error('Error handling dislike:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await handleDislike(postId);
    }
  }
}

async function handleReglorp(postId) {
  const username = room.party.client.username;
  try {
    await room.store.update({
      id: 'posts',
      dependencies: {
        postId,
        username
      },
      updateFunction: posts => {
        return posts.map(post => {
          if (post.id === postId) {
            const reglorps = post.reglorps || [];
            const index = reglorps.indexOf(username);
            if (index === -1) {
              return {
                ...post,
                reglorps: [...reglorps, username]
              };
            } else {
              return {
                ...post,
                reglorps: reglorps.filter(u => u !== username)
              };
            }
          }
          return post;
        });
      }
    });
    const posts = await room.store.get('posts');
    const updatedPost = posts.find(p => p.id === postId);
    if (updatedPost) {
      notifyInteractions(updatedPost, 'reglorp');
    }
    await refreshPosts();
  } catch (error) {
    console.error('Error handling reglorp:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await handleReglorp(postId);
    }
  }
}

const audioContext = new (window.AudioContext || window.webkitAudioContext)();
function playAlienSound() {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  oscillator.type = 'sine';
  oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
  gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
  oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.2);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
  oscillator.start();
  oscillator.stop(audioContext.currentTime + 0.3);
}

function playNotificationSound(type) {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  oscillator.type = 'sine';
  
  let startFreq = 500;
  let endFreq = 600;
  let duration = 0.2;
  
  switch(type) {
    case 'like':
      startFreq = 600;
      endFreq = 800;
      break;
    case 'dislike':
      startFreq = 400;
      endFreq = 200;
      break;
    case 'reglorp':
      startFreq = 300;
      endFreq = 600;
      break;
    case 'reply':
      startFreq = 450;
      endFreq = 550;
      break;
  }
  
  if (!Number.isFinite(startFreq) || !Number.isFinite(endFreq)) {
    return;
  }

  oscillator.frequency.setValueAtTime(startFreq, audioContext.currentTime);
  oscillator.frequency.linearRampToValueAtTime(endFreq, audioContext.currentTime + duration);
  gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.01, audioContext.currentTime + duration);
  
  oscillator.start();
  oscillator.stop(audioContext.currentTime + duration);
}

async function generateAlienReply(postId, alienName) {
  try {
    const posts = await room.store.get('posts');
    const post = posts.find(p => p.id === postId);
    if (!post) return;

    const alienResponse = await generateAlienResponse(post.content);
    const alienAvatar = alienAvatars[Math.floor(Math.random() * alienAvatars.length)];
    
    await room.store.update({
      id: 'posts',
      dependencies: {
        postId,
        alienName,
        alienResponse,
        alienAvatar
      },
      updateFunction: posts => {
        return posts.map(post => {
          if (post.id === postId) {
            const newMsg = {
              senderId: alienName,
              content: alienResponse,
              timestamp: Date.now()
            };
            return {
              ...post,
              replies: [...post.replies, newMsg]
            };
          }
          return post;
        });
      }
    });

    const updatedPosts = await room.store.get('posts');
    const updatedPost = updatedPosts.find(p => p.id === postId);
    if (updatedPost) {
      notifyInteractions(updatedPost, 'reply');
    }
  } catch (error) {
    console.error('Error generating alien reply:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await generateAlienReply(postId, alienName);
    }
  }
}

async function generateAlienResponse(userPostContent) {
  return alienPosts[Math.floor(Math.random() * alienPosts.length)];
}

async function letAliensInteract() {
  try {
    const posts = await room.store.get('posts');
    const realUserPosts = posts.filter(post => 
      !alienNames.includes(post.username) && 
      ![...wormPosts, ...gregPosts].includes(post.content)
    );
    
    if (realUserPosts.length > 0) {
      const randomPost = realUserPosts[Math.floor(Math.random() * realUserPosts.length)];
      const randomAlienIndex = Math.floor(Math.random() * alienNames.length);
      const randomAlien = alienNames[randomAlienIndex];
      const shouldReply = Math.random() < 0.3;
      
      if (shouldReply) {
        await generateAlienReply(randomPost.id, randomAlien);
      } else {
        const interactions = ['like', 'dislike', 'reglorp'];
        const randomInteraction = interactions[Math.floor(Math.random() * interactions.length)];
        await room.store.update({
          id: 'posts',
          dependencies: { postId: randomPost.id, username: randomAlien },
          updateFunction: posts => {
            return posts.map(post => {
              if (post.id === randomPost.id) {
                const newPost = {...post};
                if (randomInteraction === 'like') {
                  newPost.likes = [...(post.likes || []), randomAlien];
                } else if (randomInteraction === 'dislike') {
                  newPost.dislikes = [...(post.dislikes || []), randomAlien];
                } else if (randomInteraction === 'reglorp') {
                  newPost.reglorps = [...(post.reglorps || []), randomAlien];
                }
                return newPost;
              }
              return post;
            });
          }
        });
        const latestPosts = await room.store.get('posts');
        const notifyPost = latestPosts.find(p => p.id === randomPost.id);
        if (notifyPost) {
          notifyInteractions(notifyPost, randomInteraction);
        }
      }
      await refreshPosts();
    }
  } catch (error) {
    console.error('Error in alien interactions:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await letAliensInteract();
    }
  }
}

function spawnUFOs() {
  const numberOfUFOs = 5;
  const ufoChars = ['üõ∏', 'üëΩ'];
  
  for (let i = 0; i < numberOfUFOs; i++) {
    const ufo = document.createElement('div');
    ufo.className = 'flying-ufo';
    ufo.innerText = ufoChars[i % ufoChars.length];
    document.body.appendChild(ufo);

    const animateUFO = () => {
      const newX = Math.random() * window.innerWidth;
      const newY = Math.random() * window.innerHeight;
      ufo.style.transform = `translate(${newX}px, ${newY}px)`;
    };

    setInterval(animateUFO, 2000);
  }
}

function createFloatingParticles() {
  const numberOfParticles = 50;
  
  for (let i = 0; i < numberOfParticles; i++) {
    const particle = document.createElement('div');
    particle.className = 'floating-particle';
    
    particle.style.left = Math.random() * window.innerWidth + 'px';
    particle.style.top = Math.random() * window.innerHeight + 'px';
    
    document.body.appendChild(particle);
    
    const animateParticle = () => {
      const newX = Math.random() * window.innerWidth;
      const newY = Math.random() * window.innerHeight;
      particle.style.transform = `translate(${newX}px, ${newY}px)`;
    };
    
    animateParticle();
    setInterval(animateParticle, 5000 + Math.random() * 5000);
  }
}

function createPlanets() {
  const numberOfPlanets = 3;
  const planetEmojis = ['üåç', 'üåé', 'üåè'];
  
  for (let i = 0; i < numberOfPlanets; i++) {
    const planet = document.createElement('div');
    planet.className = 'planet';
    planet.textContent = planetEmojis[i % planetEmojis.length];
    planet.style.fontSize = (30 + Math.random() * 20) + 'px';
    
    planet.style.left = (Math.random() * 80 + 10) + '%';
    planet.style.top = (Math.random() * 80 + 10) + '%';
    
    const orbitDirection = Math.random() > 0.5 ? 'orbitRight' : 'orbitLeft';
    planet.style.animation = `${orbitDirection} ${20 + Math.random() * 20}s linear infinite, planetPulse 3s ease-in-out infinite`;
    
    document.body.appendChild(planet);
  }
}

spawnUFOs();
createFloatingParticles();
createPlanets();
addRandomAlienPost();
refreshPosts();
createFollowsTable().then(fetchFollows);
setInterval(fetchFollows, 1000);

async function saveProfileBio() {
  const peers = room.party.peers;
  const clientId = openProfileClientId;
  let userData = peers[clientId];
  
  if (!userData && clientId === room.party.client.id) {
    userData = room.party.client;
  }
  
  if (!userData) return;
  
  if (userData.username !== room.party.client.username) {
    console.log('Cannot edit another user\'s bio');
    return;
  }

  const { username } = userData;
  const newBio = document.getElementById('profileBioEdit').value.trim();
  
  try {
    await insertOrUpdateBio(username, newBio);
    document.getElementById('profileBio').textContent = newBio;
    hideBioEdit();
  } catch (error) {
    console.error('Error saving bio:', error);
    alert('Failed to save bio. Please try again.');
  }
}

async function showProfile(clientId) {
  openProfileClientId = clientId;
  const modal = document.getElementById('profileModal');
  modal.style.display = 'block';
  modal.style.left = window.innerWidth / 2 - modal.offsetWidth / 2 + 'px';
  modal.style.top = window.innerHeight / 2 - modal.offsetHeight / 2 + 'px';
  
  const peers = room.party.peers;
  let userData;
  if (peers[clientId]) {
    userData = peers[clientId];
  } else if (clientId === room.party.client.id) {
    userData = room.party.client;
  }
  if (!userData) {
    hideProfileModal();
    return;
  }
  
  const { username, avatarUrl } = userData;
  const isCurrentUser = username === room.party.client.username;
  
  const editBioButton = document.getElementById('editBioButton');
  editBioButton.style.display = isCurrentUser ? 'block' : 'none';
  
  const profileAvatar = document.getElementById('profileAvatar');
  if (avatarUrl && avatarUrl.startsWith('http')) {
    profileAvatar.style.display = 'block';
    profileAvatar.src = avatarUrl;
  } else {
    profileAvatar.style.display = 'none';
    const existingEmoji = profileAvatar.parentNode.querySelector('span');
    if (existingEmoji) existingEmoji.remove();
    const emojiSpan = document.createElement('span');
    emojiSpan.textContent = avatarUrl || 'üëΩ';
    emojiSpan.style.fontSize = '80px';
    emojiSpan.style.display = 'block';
    emojiSpan.style.textAlign = 'center';
    emojiSpan.style.marginBottom = '10px';
    profileAvatar.parentNode.insertBefore(emojiSpan, profileAvatar);
  }
  
  document.getElementById('profileUsername').textContent = username;
  
  await fetchBios();
  const bioData = window.biosData?.find(b => b.username === username);
  const bioText = bioData ? bioData.bio : 'No bio set.';
  document.getElementById('profileBio').textContent = bioText;
  document.getElementById('profileBioEdit').value = bioText;
  
  hideBioEdit();
}
let biosData = [];
window.biosData = biosData;

document.addEventListener('DOMContentLoaded', () => {
  createBiosTable().then(() => {
    fetchBios();
    setInterval(fetchBios, 1000);
  });
});
async function fetchBios() {
  try {
    let query = `SELECT * FROM bios`;
    let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
      sql: query
    }));
    let data = await results.json();
    
    if (data && Array.isArray(data)) {
      window.biosData = data;
    } else if (data && Array.isArray(data.rows)) {
      window.biosData = data.rows;
    } else {
      window.biosData = [];
    }
    
    console.log('Updated bios data:', window.biosData);
  } catch (error) {
    console.error('Error fetching bios:', error);
    window.biosData = [];
  }
}

async function insertOrUpdateBio(username, newBio) {
  const sanitizedBio = newBio.replace(/'/g, "''");
  
  try {
    let existingBio = window.biosData?.find(b => b.username === username);
    let query;
    
    if (existingBio) {
      query = `UPDATE bios SET bio='${sanitizedBio}' WHERE username='${username}'`;
    } else {
      query = `INSERT INTO bios (username, bio) VALUES ('${username}', '${sanitizedBio}')`;
    }
    
    let results = await fetch('/api/v1/sql/?' + new URLSearchParams({
      sql: query
    }));
    let data = await results.json();
    console.log("insertOrUpdateBio response:", data);
    
    await fetchBios();
    
    return true;
  } catch (error) {
    console.error('Error updating bio:', error);
    throw error;
  }
}

let openProfileClientId = null;
let inboxOpen = false;
let currentDMThreadId = null;
function showInboxModal() {
  inboxOpen = true;
  const modal = document.getElementById('inboxModal');
  modal.style.display = 'block';
  modal.style.left = window.innerWidth / 2 - modal.offsetWidth / 2 + 'px';
  modal.style.top = window.innerHeight / 2 - modal.offsetHeight / 2 + 'px';
  refreshDMThreads();
}

function hideInboxModal() {
  inboxOpen = false;
  document.getElementById('inboxModal').style.display = 'none';
}

async function refreshDMThreads() {
  const dmThreadsList = document.getElementById('dmThreadsList');
  if (!dmThreadsList) return;
  dmThreadsList.innerHTML = '';
  const currentClientId = room.party.client.id;
  const dms = (await room.store.get('dms')) || [];
  const myThreads = dms.filter(thread => thread.participants.includes(currentClientId));
  myThreads.forEach(thread => {
    const otherUsers = thread.participants.filter(pid => pid !== currentClientId);
    let threadTitle = "Me";
    const peers = room.party.peers;
    if (otherUsers.length > 0) {
      const otherPeerId = otherUsers[0];
      if (peers[otherPeerId]) {
        threadTitle = peers[otherPeerId].username;
      }
    }
    const item = document.createElement('div');
    item.className = 'dm-thread-item';
    item.textContent = threadTitle;
    item.addEventListener('click', () => {
      openExistingThread(thread.id);
    });
    dmThreadsList.appendChild(item);
  });
}

function hideDMModal() {
  currentDMThreadId = null;
  document.getElementById('dmModal').style.display = 'none';
}

async function openExistingThread(threadId) {
  currentDMThreadId = threadId;
  showDMModal();
  await refreshDMConversation();
}

function showDMModal() {
  const modal = document.getElementById('dmModal');
  modal.style.display = 'block';
  modal.style.left = window.innerWidth / 2 - modal.offsetWidth / 2 + 'px';
  modal.style.top = window.innerHeight / 2 - modal.offsetHeight / 2 + 'px';
}

async function refreshDMConversation() {
  if (!currentDMThreadId) return;
  const dms = (await room.store.get('dms')) || [];
  const thread = dms.find(t => t.id === currentDMThreadId);
  const peers = room.party.peers;
  const currentClientId = room.party.client.id;
  if (!thread) {
    document.getElementById('dmConversation').innerHTML = '<p>No conversation found.</p>';
    return;
  }
  const otherUsers = thread.participants.filter(pid => pid !== currentClientId);
  let threadTitle = 'Me';
  if (otherUsers.length > 0 && peers[otherUsers[0]]) {
    threadTitle = peers[otherUsers[0]].username;
  }
  document.getElementById('dmThreadTitle').textContent = 'Conversation with ' + threadTitle;
  const conversationEl = document.getElementById('dmConversation');
  conversationEl.innerHTML = '';
  thread.messages.forEach(msg => {
    const msgDiv = document.createElement('div');
    msgDiv.className = 'dm-message';
    let senderName = 'Me';
    if (msg.senderId !== currentClientId && peers[msg.senderId]) {
      senderName = peers[msg.senderId].username;
    } else if (msg.senderId !== currentClientId) {
      senderName = 'Unknown User';
    }
    msgDiv.innerHTML = `
      <div class="dm-sender">${senderName}:</div>
      <div>${msg.content}</div>
    `;
    conversationEl.appendChild(msgDiv);
  });
  conversationEl.scrollTop = conversationEl.scrollHeight;
}

async function dmSendMessage() {
  const input = document.getElementById('dmInput');
  const message = input.value.trim();
  if (!message || !currentDMThreadId) return;
  const sanitizedContent = sanitizeContent(message);
  const currentClientId = room.party.client.id;
  try {
    await room.store.update({
      id: 'dms',
      dependencies: {
        currentDMThreadId,
        sanitizedContent,
        currentClientId
      },
      updateFunction: threads => {
        return threads.map(thread => {
          if (thread.id === currentDMThreadId) {
            const newMsg = {
              senderId: currentClientId,
              content: sanitizedContent,
              timestamp: Date.now()
            };
            return {
              ...thread,
              messages: [...thread.messages, newMsg]
            };
          }
          return thread;
        });
      }
    });
    input.value = '';
    await refreshDMConversation();
    playAlienSound();
  } catch (err) {
    console.error('Error sending DM:', err);
    if (err.message?.includes('WebSocket') || err.message?.includes('connection')) {
      await reconnectWebSocket();
      dmSendMessage();
    }
  }
}

let currentDMThreadIdTab = null;
function openDM(targetClientId) {
  showMessagesTab();
  createOrOpenThreadTab(targetClientId);
}

async function createOrOpenThreadTab(targetClientId) {
  const currentClientId = room.party.client.id;
  const dms = (await room.store.get('dms')) || [];
  let existingThread = dms.find(thread => {
    return thread.participants.length === 2 && thread.participants.includes(currentClientId) && thread.participants.includes(targetClientId);
  });
  if (!existingThread) {
    const newThreadId = Date.now().toString();
    const newThread = {
      id: newThreadId,
      participants: [currentClientId, targetClientId],
      messages: []
    };
    await room.store.update({
      id: 'dms',
      dependencies: {
        newThread
      },
      updateFunction: (oldDms = []) => [...oldDms, newThread]
    });
    existingThread = newThread;
  }
  currentDMThreadIdTab = existingThread.id;
  await refreshDMThreadsTab();
  refreshDMConversationTab();
}

async function refreshDMThreadsTab() {
  const listContainer = document.getElementById('dmThreadsListContainer');
  if (!listContainer) return;
  listContainer.innerHTML = '';
  const currentClientId = room.party.client.id;
  const dms = (await room.store.get('dms')) || [];
  const myThreads = dms.filter(thread => thread.participants.includes(currentClientId));
  const peers = room.party.peers;
  myThreads.forEach(thread => {
    const otherUsers = thread.participants.filter(pid => pid !== currentClientId);
    let threadTitle = "Me";
    if (otherUsers.length > 0 && peers[otherUsers[0]]) {
      threadTitle = peers[otherUsers[0]].username;
    }
    const item = document.createElement('div');
    item.className = 'dm-thread-item';
    item.textContent = threadTitle;
    item.addEventListener('click', () => {
      currentDMThreadIdTab = thread.id;
      refreshDMConversationTab();
    });
    listContainer.appendChild(item);
  });
}

async function refreshDMConversationTab() {
  if (!currentDMThreadIdTab) {
    document.getElementById('dmThreadTitleTab').textContent = 'Select a conversation';
    document.getElementById('dmConversationContainer').innerHTML = '';
    return;
  }
  const dms = (await room.store.get('dms')) || [];
  const thread = dms.find(t => t.id === currentDMThreadIdTab);
  const peers = room.party.peers;
  const currentClientId = room.party.client.id;
  if (!thread) {
    document.getElementById('dmThreadTitleTab').textContent = 'No conversation found.';
    document.getElementById('dmConversationContainer').innerHTML = '';
    return;
  }
  const otherUsers = thread.participants.filter(pid => pid !== currentClientId);
  let threadTitle = 'Me';
  if (otherUsers.length > 0 && peers[otherUsers[0]]) {
    threadTitle = peers[otherUsers[0]].username;
  }
  document.getElementById('dmThreadTitleTab').textContent = 'Conversation with ' + threadTitle;
  const conversationEl = document.getElementById('dmConversationContainer');
  conversationEl.innerHTML = '';
  thread.messages.forEach(msg => {
    const msgDiv = document.createElement('div');
    msgDiv.className = 'dm-message';
    let senderName = 'Me';
    if (msg.senderId !== currentClientId && peers[msg.senderId]) {
      senderName = peers[msg.senderId].username;
    } else if (msg.senderId !== currentClientId) {
      senderName = 'Unknown User';
    }
    msgDiv.innerHTML = `
      <div class="dm-sender">${senderName}:</div>
      <div>${msg.content}</div>
    `;
    conversationEl.appendChild(msgDiv);
  });
  conversationEl.scrollTop = conversationEl.scrollHeight;
}

async function dmSendMessageTab() {
  const input = document.getElementById('dmInputTab');
  const message = input.value.trim();
  if (!message || !currentDMThreadIdTab) return;
  const sanitizedContent = sanitizeContent(message);
  const currentClientId = room.party.client.id;
  try {
    await room.store.update({
      id: 'dms',
      dependencies: {
        currentDMThreadIdTab,
        sanitizedContent,
        currentClientId
      },
      updateFunction: threads => {
        return threads.map(thread => {
          if (thread.id === currentDMThreadIdTab) {
            const newMsg = {
              senderId: currentClientId,
              content: sanitizedContent,
              timestamp: Date.now()
            };
            return {
              ...thread,
              messages: [...thread.messages, newMsg]
            };
          }
          return thread;
        });
      }
    });
    input.value = '';
    refreshDMConversationTab();
    playAlienSound();
  } catch (err) {
    console.error('Error sending DM:', err);
    if (err.message?.includes('WebSocket') || err.message?.includes('connection')) {
      await reconnectWebSocket();
      dmSendMessageTab();
    }
  }
}

async function safeSendToStore(updateFn) {
  try {
    await updateFn();
    await refreshPosts();
  } catch (error) {
    console.error('Error updating store:', error);
    if (error.message?.includes('WebSocket') || error.message?.includes('connection')) {
      await reconnectWebSocket();
      await updateFn();
      await refreshPosts();
    }
  }
}

document.querySelector('.crawling-worm').addEventListener('click', showWormMessage);
function showWormMessage() {
  const worm = document.querySelector('.crawling-worm');
  const existingMessage = document.querySelector('.worm-message');
  if (existingMessage) {
    existingMessage.remove();
  }
  const message = document.createElement('div');
  message.className = 'worm-message';
  message.textContent = wormMessages[Math.floor(Math.random() * wormMessages.length)];
  worm.parentNode.appendChild(message);
  setTimeout(() => {
    if (message.parentNode) {
      message.remove();
    }
  }, 4000);
  playAlienSound();
}

document.addEventListener('DOMContentLoaded', () => {
  createBiosTable().then(() => {
    fetchBios();
    setInterval(fetchBios, 1000);
  });
  document.getElementById('profileSaveButton').addEventListener('click', saveProfileBio);
  document.getElementById('profileCancelButton').addEventListener('click', () => {
    hideBioEdit();
    showProfile(openProfileClientId);
  });
  const profileBioEdit = document.getElementById('profileBioEdit');
  profileBioEdit.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      saveProfileBio();
    }
  });
});

function hideProfileModal() {
  openProfileClientId = null;
  document.getElementById('profileModal').style.display = 'none';
}

function hideBioEdit() {
  document.getElementById('profileBioEdit').style.display = 'none';
  document.getElementById('profileBio').style.display = 'block';
  document.getElementById('profileEditButtons').style.display = 'none';
  document.getElementById('editBioButton').style.display = 'block';
}
setInterval(letAliensInteract, 30000 + Math.random() * 60000);
createFloatingParticles();

</script>
</body>
</html>
<meta charset="UTF-8">
<title>Space Defender - Aventure Cosmique</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: 'Orbitron', sans-serif;
    background-color: #000;
    color: #fff;
    overflow: hidden;
    cursor: none;
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
  }
  #mainMenu, #gameOverMenu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    background-color: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    border: 2px solid #4CAF50;
  }
  button, input[type="text"] {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer;
    border-radius: 5px;
    font-family: 'Orbitron', sans-serif;
    transition: all 0.3s ease;
  }
  input[type="text"] {
    background-color: #2c3e50;
    padding: 10px;
    width: 200px;
  }
  button:hover {
    background-color: #45a049;
    transform: scale(1.05);
  }
  #leaderboard {
    margin-top: 20px;
    text-align: left;
  }
  #leaderboard h3 {
    text-align: center;
  }
  @font-face {
    font-family: 'Orbitron';
    src: url('https://fonts.gstatic.com/s/orbitron/v19/yMJRMIlzdpvBhQQL_Qq7dy1biN15.woff2') format('woff2');
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="mainMenu">
  <h1>Space Defender</h1>
  <input type="text" id="playerName" placeholder="Entrez votre nom" maxlength="15">
  <button id="startButton">Démarrer la mission</button>
  <div id="leaderboard">
    <h3>Tableau des scores</h3>
    <ol id="leaderboardList"></ol>
  </div>
</div>
<div id="gameOverMenu" style="display: none;">
  <h2>Mission terminée</h2>
  <p>Score final: <span id="finalScore"></span></p>
  <button id="restartButton">Nouvelle mission</button>
  <button id="mainMenuButton">Menu Principal</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mainMenu = document.getElementById('mainMenu');
const gameOverMenu = document.getElementById('gameOverMenu');
const startButton = document.getElementById('startButton');
const restartButton = document.getElementById('restartButton');
const mainMenuButton = document.getElementById('mainMenuButton');
const finalScoreSpan = document.getElementById('finalScore');
const leaderboardList = document.getElementById('leaderboardList');
const playerNameInput = document.getElementById('playerName');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let gameLoop;
let plane;
let asteroids = [];
let toughAsteroids = [];
let ufos = [];
let bullets = [];
let enemyBullets = [];
let powerUps = [];
let score = 0;
let gameTime = 0;
let leaderboard = [];
let mouseY = canvas.height / 2;
let isMouseDown = false;
let background;
let specialAttack = null;
let specialAttackCooldown = 0;
let laserBeamEndTime = 0;
let fireRateBoost = 1;
let fireRateBoostEndTime = 0;
let playerName = "";
let isGameActive = false;

// Sons existants
const shootSound = new Audio('https://opengameart.org/sites/default/files/laser1.wav');
const explosionSound = new Audio('https://opengameart.org/sites/default/files/explosion_1.wav');
const powerUpSound = new Audio('https://opengameart.org/sites/default/files/powerUp.wav');
const backgroundMusic = new Audio('https://opengameart.org/sites/default/files/DST-RailJet-LongSeamlessLoop.ogg');
backgroundMusic.loop = true;

// Nouveaux sons
const asteroidDestroySound = new Audio('https://opengameart.org/sites/default/files/rumble1.wav');
const ufoDestroySound = new Audio('https://opengameart.org/sites/default/files/explosion_2.wav');
const powerUpCollectSound = new Audio('https://opengameart.org/sites/default/files/powerUp9.wav');
const specialAttackSound = new Audio('https://opengameart.org/sites/default/files/laser4.wav');
const laserBeamSound = new Audio('https://opengameart.org/sites/default/files/laser5.wav');

function playSound(sound) {
  sound.currentTime = 0;
  sound.play().catch(e => console.log("Audio play failed:", e));
}

function createStarryBackground() {
  const offscreenCanvas = document.createElement('canvas');
  offscreenCanvas.width = canvas.width;
  offscreenCanvas.height = canvas.height;
  const offscreenCtx = offscreenCanvas.getContext('2d');

  offscreenCtx.fillStyle = '#000033';
  offscreenCtx.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < 200; i++) {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    const radius = Math.random() * 1.5;
    const opacity = Math.random();

    offscreenCtx.beginPath();
    offscreenCtx.arc(x, y, radius, 0, Math.PI * 2);
    offscreenCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
    offscreenCtx.fill();
  }

  return offscreenCanvas;
}

class Plane {
  constructor() {
    this.width = 60;
    this.height = 40;
    this.x = 50;
    this.y = canvas.height / 2 - this.height / 2;
    this.shootCooldown = 0;
  }

  draw() {
    ctx.fillStyle = '#3498db';
    ctx.beginPath();
    ctx.moveTo(this.x, this.y + this.height / 2);
    ctx.lineTo(this.x + this.width, this.y);
    ctx.lineTo(this.x + this.width, this.y + this.height);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#2980b9';
    ctx.beginPath();
    ctx.moveTo(this.x + this.width * 0.2, this.y + this.height * 0.2);
    ctx.lineTo(this.x + this.width * 0.6, this.y);
    ctx.lineTo(this.x + this.width * 0.6, this.y + this.height);
    ctx.lineTo(this.x + this.width * 0.2, this.y + this.height * 0.8);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#ecf0f1';
    ctx.beginPath();
    ctx.arc(this.x + this.width * 0.8, this.y + this.height / 2, this.height * 0.2, 0, Math.PI * 2);
    ctx.fill();
  }

  move() {
    this.y = mouseY - this.height / 2;
    if (this.y < 0) this.y = 0;
    if (this.y > canvas.height - this.height) this.y = canvas.height - this.height;
  }

  shoot() {
    if (this.shootCooldown <= 0) {
      bullets.push(new Bullet(this.x + this.width, this.y + this.height / 2));
      this.shootCooldown = 30 / fireRateBoost;
      playSound(shootSound);
    }
    this.shootCooldown--;
  }

  useSpecialAttack() {
    if (specialAttack && specialAttackCooldown === 0) {
      switch (specialAttack) {
        case 'spreadShot':
          for (let i = -2; i <= 2; i++) {
            bullets.push(new Bullet(this.x + this.width, this.y + this.height / 2, 10, '#f39c12', i * 2));
          }
          specialAttackCooldown = 180;
          playSound(specialAttackSound);
          break;
        case 'laserBeam':
          laserBeamEndTime = gameTime + 180;
          specialAttackCooldown = 600;
          playSound(laserBeamSound);
          break;
        case 'homingMissile':
          bullets.push(new HomingMissile(this.x + this.width, this.y + this.height / 2));
          specialAttackCooldown = 300;
          playSound(specialAttackSound);
          break;
      }
    }
  }
}

class Asteroid {
  constructor(tough = false) {
    this.width = tough ? 50 : 40;
    this.height = tough ? 50 : 40;
    this.x = canvas.width;
    this.y = Math.random() * (canvas.height - this.height);
    this.speed = 1 + Math.random() * 2;
    this.rotation = 0;
    this.rotationSpeed = Math.random() * 0.1 - 0.05;
    this.maxHealth = tough ? 3 : 1;
    this.health = this.maxHealth;
    this.tough = tough;
  }

  draw() {
    ctx.save();
    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
    ctx.rotate(this.rotation);
    ctx.fillStyle = this.tough ? '#8e44ad' : '#95a5a6';
    ctx.beginPath();
    ctx.moveTo(-this.width / 2, 0);
    ctx.lineTo(-this.width / 4, -this.height / 2);
    ctx.lineTo(this.width / 4, -this.height / 2);
    ctx.lineTo(this.width / 2, 0);
    ctx.lineTo(this.width / 4, this.height / 2);
    ctx.lineTo(-this.width / 4, this.height / 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    this.drawHealthBar();
  }

  drawHealthBar() {
    const healthPercentage = this.health / this.maxHealth;
    const barWidth = this.width;
    const barHeight = 5;
    const barX = this.x;
    const barY = this.y - 10;

    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
    ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
  }

  move() {
    this.x -= this.speed;
    this.rotation += this.rotationSpeed;
  }
}

class UFO {
  constructor() {
    this.width = 60;
    this.height = 30;
    this.x = canvas.width;
    this.y = Math.random() * (canvas.height - this.height);
    this.speed = 1.5 + Math.random();
    this.shootInterval = Math.floor(Math.random() * 100) + 50;
    this.maxHealth = 2;
    this.health = this.maxHealth;
  }

  draw() {
    ctx.fillStyle = '#e74c3c';
    ctx.beginPath();
    ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, this.height / 4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#3498db';
    ctx.beginPath();
    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 4, Math.PI, 0);
    ctx.fill();

    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = '#f1c40f';
      ctx.beginPath();
      ctx.arc(this.x + this.width * (0.25 + i * 0.25), this.y + this.height * 0.8, this.width * 0.05, 0, Math.PI * 2);
      ctx.fill();
    }

    this.drawHealthBar();
  }

  drawHealthBar() {
    const healthPercentage = this.health / this.maxHealth;
    const barWidth = this.width;
    const barHeight = 5;
    const barX = this.x;
    const barY = this.y - 10;

    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
    ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
  }

  move() {
    this.x -= this.speed;
    if (gameTime % this.shootInterval === 0) {
      enemyBullets.push(new Bullet(this.x, this.y + this.height / 2, -5, '#e74c3c'));
      playSound(shootSound);
    }
  }
}

class Bullet {
  constructor(x, y, speed = 10, color = '#f39c12', angleOffset = 0) {
    this.width = 10;
    this.height = 5;
    this.x = x;
    this.y = y;
    this.speed = speed;
    this.color = color;
    this.angleOffset = angleOffset * Math.PI / 180;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }

  move() {
    this.x += this.speed * Math.cos(this.angleOffset);
    this.y += this.speed * Math.sin(this.angleOffset);
  }
}

class LaserBeam extends Bullet {
  constructor(x, y) {
    super(x, y, 20, '#3498db');
    this.width = canvas.width - x;
    this.height = 10;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y - this.height / 2, this.width, this.height);
  }

  move() {
    // Laser beam doesn't move, it disappears after duration
  }
}

class HomingMissile extends Bullet {
  constructor(x, y) {
    super(x, y, 5, '#e67e22');
    this.width = 15;
    this.height = 8;
    this.target = null;
  }

  findTarget() {
    let closestDistance = Infinity;
    let closestTarget = null;
    const targets = [...asteroids, ...toughAsteroids, ...ufos];

    for (const target of targets) {
      const distance = Math.hypot(target.x - this.x, target.y - this.y);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestTarget = target;
      }
    }

    this.target = closestTarget;
  }

  move() {
    if (!this.target || this.target.health <= 0) {
      this.findTarget();
    }

    if (this.target) {
      const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
      this.x += this.speed * Math.cos(angle);
      this.y += this.speed * Math.sin(angle);
    } else {
      super.move();
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(Math.atan2(this.target ? this.target.y - this.y : 0, this.target ? this.target.x - this.x : 1));
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-this.width, this.height / 2);
    ctx.lineTo(-this.width, -this.height / 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

class PowerUp {
  constructor() {
    this.width = 30;
    this.height = 30;
    this.x = canvas.width;
    this.y = Math.random() * (canvas.height - this.height);
    this.speed = 2;
    this.type = this.getRandomType();
  }

  getRandomType() {
    const rand = Math.random();
    if (rand < 0.4) return 'fireRateBoost';
    if (rand < 0.7) return 'spreadShot';
    if (rand < 0.9) return 'laserBeam';
    return 'homingMissile';
  }

  draw() {
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath();
    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.font = '20px Orbitron';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    let symbol;
    switch (this.type) {
      case 'fireRateBoost':
        symbol = '⚡';
        break;
      case 'spreadShot':
        symbol = '⇶';
        break;
      case 'laserBeam':
        symbol = '↠';
        break;
      case 'homingMissile':
        symbol = '☄';
        break;
    }
    ctx.fillText(symbol, this.x + this.width / 2, this.y + this.height / 2);
  }

  move() {
    this.x -= this.speed;
  }
}

function startGame() {
  playerName = playerNameInput.value.trim() || "Anonyme";
  mainMenu.style.display = 'none';
  gameOverMenu.style.display = 'none';
  plane = new Plane();
  asteroids = [];
  toughAsteroids = [];
  ufos = [];
  bullets = [];
  enemyBullets = [];
  powerUps = [];
  score = 0;
  gameTime = 0;
  specialAttack = null;
  specialAttackCooldown = 0;
  laserBeamEndTime = 0;
  fireRateBoost = 1;
  fireRateBoostEndTime = 0;
  background = createStarryBackground();
  isGameActive = true;
  canvas.requestPointerLock();
  gameLoop = setInterval(update, 1000 / 60);
  backgroundMusic.play().catch(e => console.log("Background music play failed:", e));
}

function endGame() {
  clearInterval(gameLoop);
  gameOverMenu.style.display = 'block';
  finalScoreSpan.textContent = score;
  updateLeaderboard({ name: playerName, score: score });
  isGameActive = false;
  document.exitPointerLock();
  backgroundMusic.pause();
  backgroundMusic.currentTime = 0;
}

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.drawImage(background, 0, 0);

  gameTime++;
  
  const spawnRate = Math.max(120 - Math.floor(gameTime / 600), 60);
  if (gameTime % spawnRate === 0) {
    if (Math.random() < 0.7) {
      asteroids.push(new Asteroid());
    } else {
      toughAsteroids.push(new Asteroid(true));
    }
  }

  if (gameTime % 180 === 0 && score > 10) {
    ufos.push(new UFO());
  }

  if (gameTime % 300 === 0) {
    powerUps.push(new PowerUp());
  }

  plane.move();
  plane.draw();
  if (isMouseDown) {
    plane.shoot();
    plane.useSpecialAttack();
  }

  updateAsteroids(asteroids);
  updateAsteroids(toughAsteroids);
  updateUFOs();
  updateBullets();
  updateEnemyBullets();
  updatePowerUps();

  if (specialAttackCooldown > 0) {
    specialAttackCooldown--;
  }

  if (fireRateBoostEndTime > gameTime) {
    fireRateBoost = 2;
  } else {
    fireRateBoost = 1;
  }

  if (gameTime <= laserBeamEndTime) {
    const laserBeam = new LaserBeam(plane.x + plane.width, plane.y + plane.height / 2);
    laserBeam.draw();
    checkLaserCollisions(laserBeam);
    if (gameTime % 10 === 0) {
      playSound(laserBeamSound);
    }
  }

  drawScore();
  drawSpecialAttack();
  drawCursor();
}

function updateAsteroids(asteroidArray) {
  for (let i = asteroidArray.length - 1; i >= 0; i--) {
    const asteroid = asteroidArray[i];
    asteroid.draw();
    asteroid.move();

    if (asteroid.x + asteroid.width < 0) {
      endGame();
      return;
    }

    if (checkCollision(plane, asteroid)) {
      endGame();
      return;
    }

    if (asteroid.health <= 0) {
      asteroidArray.splice(i, 1);
      score += asteroid.tough ? 2 : 1;
      playSound(asteroidDestroySound);
    }
  }
}

function updateUFOs() {
  for (let i = ufos.length - 1; i >= 0; i--) {
    const ufo = ufos[i];
    ufo.draw();
    ufo.move();

    if (ufo.x + ufo.width < 0) {
      ufos.splice(i, 1);
    }

    if (checkCollision(plane, ufo)) {
      endGame();
      return;
    }

    if (ufo.health <= 0) {
      ufos.splice(i, 1);
      score += 3;
      playSound(ufoDestroySound);
    }
  }
}

function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    bullet.draw();
    bullet.move();

    if (bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
      bullets.splice(i, 1);
      continue;
    }

    if (!(bullet instanceof LaserBeam)) {
      let hitTarget = false;

      const targets = [...asteroids, ...toughAsteroids, ...ufos];
      for (let j = targets.length - 1; j >= 0; j--) {
        const target = targets[j];
        if (checkCollision(bullet, target)) {
          hitTarget = true;
          target.health--;
          if (target.health <= 0) {
            if (target instanceof UFO) {
              ufos.splice(ufos.indexOf(target), 1);
              score += 3;
              playSound(ufoDestroySound);
            } else if (target.tough) {
              toughAsteroids.splice(toughAsteroids.indexOf(target), 1);
              score += 2;
              playSound(asteroidDestroySound);
            } else {
              asteroids.splice(asteroids.indexOf(target), 1);
              score += 1;
              playSound(asteroidDestroySound);
            }
          }
          break;
        }
      }

      if (hitTarget) {
        bullets.splice(i, 1);
      }
    }
  }
}

function checkLaserCollisions(laserBeam) {
  const targets = [...asteroids, ...toughAsteroids, ...ufos];
  for (let i = targets.length - 1; i >= 0; i--) {
    const target = targets[i];
    if (checkCollision(laserBeam, target)) {
      target.health--;
      if (target.health <= 0) {
        if (target instanceof UFO) {
          ufos.splice(ufos.indexOf(target), 1);
          score += 3;
          playSound(ufoDestroySound);
        } else if (target.tough) {
          toughAsteroids.splice(toughAsteroids.indexOf(target), 1);
          score += 2;
          playSound(asteroidDestroySound);
        } else {
          asteroids.splice(asteroids.indexOf(target), 1);
          score += 1;
          playSound(asteroidDestroySound);
        }
      }
    }
  }
}

function updateEnemyBullets() {
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const bullet = enemyBullets[i];
    bullet.draw();
    bullet.move();

    if (bullet.x + bullet.width < 0) {
      enemyBullets.splice(i, 1);
      continue;
    }

    if (checkCollision(bullet, plane)) {
      endGame();
      return;
    }
  }
}

function updatePowerUps() {
  for (let i = powerUps.length - 1; i >= 0; i--) {
    const powerUp = powerUps[i];
    powerUp.draw();
    powerUp.move();

    if (powerUp.x + powerUp.width < 0) {
      powerUps.splice(i, 1);
      continue;
    }

    if (checkCollision(powerUp, plane)) {
      if (powerUp.type === 'fireRateBoost') {
        fireRateBoostEndTime = gameTime + 300;
      } else {
        specialAttack = powerUp.type;
        specialAttackCooldown = 0;
      }
      powerUps.splice(i, 1);
      playSound(powerUpCollectSound);
    }
  }
}

function checkCollision(obj1, obj2) {
  return obj1.x < obj2.x + obj2.width &&
         obj1.x + obj1.width > obj2.x &&
         obj1.y < obj2.y + obj2.height &&
         obj1.y + obj1.height > obj2.y;
}

function drawScore() {
  ctx.fillStyle = '#fff';
  ctx.font = '20px Orbitron';
  ctx.fillText(`Score: ${score}`, 10, 30);
}

function drawSpecialAttack() {
  if (specialAttack) {
    ctx.fillStyle = '#fff';
    ctx.font = '20px Orbitron';
    let symbol;
    switch (specialAttack) {
      case 'spreadShot':
        symbol = '⇶';
        break;
      case 'laserBeam':
        symbol = '↠';
        break;
      case 'homingMissile':
        symbol = '☄';
        break;
    }
    ctx.fillText(`${symbol} ${specialAttackCooldown > 0 ? Math.ceil(specialAttackCooldown / 60) : 'Ready!'}`, 10, 60);
  }
  
  if (fireRateBoostEndTime > gameTime) {
    ctx.fillStyle = '#fff';
    ctx.font = '20px Orbitron';
    ctx.fillText(`⚡ ${Math.ceil((fireRateBoostEndTime - gameTime) / 60)}`, 10, 90);
  }
}

function drawCursor() {
  ctx.fillStyle = '#2ecc71';
  ctx.beginPath();
  ctx.arc(plane.x + plane.width, mouseY, 5, 0, Math.PI * 2);
  ctx.fill();
}

function updateLeaderboard(newScore) {
  leaderboard.push(newScore);
  leaderboard.sort((a, b) => b.score - a.score);
  leaderboard = leaderboard.slice(0, 5);
  
  leaderboardList.innerHTML = '';
  leaderboard.forEach((entry, index) => {
    const li = document.createElement('li');
    li.textContent = `${entry.name}: ${entry.score} points`;
    leaderboardList.appendChild(li);
  });
}

document.addEventListener('mousemove', (e) => {
  if (isGameActive) {
    mouseY = Math.max(0, Math.min(mouseY + e.movementY, canvas.height));
  }
});

document.addEventListener('mousedown', () => {
  if (isGameActive) {
    isMouseDown = true;
  }
});

document.addEventListener('mouseup', () => {
  if (isGameActive) {
    isMouseDown = false;
  }
});

document.addEventListener('pointerlockchange', () => {
  if (document.pointerLockElement === canvas) {
    document.addEventListener('mousemove', updatePosition, false);
  } else {
    document.removeEventListener('mousemove', updatePosition, false);
  }
}, false);

function updatePosition(e) {
  if (isGameActive) {
    mouseY = Math.max(0, Math.min(mouseY + e.movementY, canvas.height));
  }
}

startButton.addEventListener('click', startGame);
restartButton.addEventListener('click', startGame);
mainMenuButton.addEventListener('click', () => {
  gameOverMenu.style.display = 'none';
  mainMenu.style.display = 'block';
});

updateLeaderboard({ name: "Meilleur score", score: 0 });

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  background = createStarryBackground();
});

shootSound.volume = 0.3;
explosionSound.volume = 0.4;
powerUpSound.volume = 0.4;
backgroundMusic.volume = 0.2;
asteroidDestroySound.volume = 0.3;
ufoDestroySound.volume = 0.4;
powerUpCollectSound.volume = 0.4;
specialAttackSound.volume = 0.4;
laserBeamSound.volume = 0.3;

</script>
</body>
</html>
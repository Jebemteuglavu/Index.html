body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: Arial, sans-serif;
}

#gameCanvas {
    background: linear-gradient(to bottom, #000033, #000066);
}

#score {
    position: fixed;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 24px;
}

#health {
    position: fixed;
    top: 20px;
    right: 20px;
    color: white;
    font-size: 24px;
}

#pauseMessage {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 36px;
    display: none;
}

#controlsPanel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    border: 2px solid #00ff00;
    display: none;
}

#controlsPanel h2 {
    color: #00ff00;
    text-align: center;
    margin-top: 0;
}

.control-row {
    margin: 10px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.key {
    background: #333;
    padding: 5px 10px;
    border-radius: 5px;
    color: #00ff00;
    font-family: monospace;
}

/* Adding styles for alien speech bubbles */
.speech-bubble {
    position: absolute;
    background: rgba(0, 255, 0, 0.3);
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 5px 10px;
    border-radius: 10px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    pointer-events: none;
}

@keyframes fadeInOut {
    0% { opacity: 0; }
    20% { opacity: 1; }
    80% { opacity: 1; }
    100% { opacity: 0; }
}

.wave-message {
    animation: fadeInOut 2s ease-in-out;
}

/* Add after other @keyframes */
@keyframes explode {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(2); opacity: 0; }
}

.explosion {
    position: absolute;
    pointer-events: none;
    animation: explode 0.5s ease-out forwards;
}

/* Add to existing CSS */
#storePanel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 20px;
    border-radius: 10px;
    border: 2px solid #00ff00;
    display: none;
    min-width: 300px;
}

.store-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    border-bottom: 1px solid #00ff00;
}

.store-item button {
    background: #004400;
    color: #00ff00;
    border: 1px solid #00ff00;
    padding: 5px 10px;
    cursor: pointer;
}

.store-item button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Add to CSS */
.store-item.teammate {
    background: rgba(0, 100, 0, 0.3);
}

.teammate-indicator {
    position: fixed;
    color: #00ff00;
    font-size: 14px;
    pointer-events: none;
}

#storeButton {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #004400;
    color: #00ff00;
    border: 1px solid #00ff00;
    padding: 10px;
    cursor: pointer;
}

/* Add to existing CSS for help panel */
#helpPanel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 20px;
    border-radius: 10px;
    border: 2px solid #00ff00;
    display: none;
    min-width: 300px;
    max-width: 500px;
}

.help-section {
    margin: 15px 0;
}

.help-section h3 {
    color: #00ff00;
    margin-bottom: 10px;
}

.help-section p {
    margin: 5px 0;
    color: #cccccc;
}

/* Add styles for tips panel */
#tipsPanel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 20px;
    border-radius: 10px;
    border: 2px solid #00ff00;
    display: none;
    min-width: 300px;
    max-width: 500px;
}

.tips-section ul {
    color: #00ff00;
    line-height: 1.5;
}

#tryAgainBtn {
    position: fixed;
    top: 60%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #004400;
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 10px 20px;
    font-size: 24px;
    cursor: pointer;
    display: none;
    border-radius: 5px;
}

#tryAgainBtn:hover {
    background: #006600;
}

/* Add to existing CSS for missile trails */
@keyframes missileTrail {
    0% { opacity: 0.8; }
    100% { opacity: 0; }
}

.missile-trail {
    position: absolute;
    background: linear-gradient(to top, #ff6600, transparent);
    pointer-events: none;
    animation: missileTrail 0.3s forwards;
}

/* Add to existing CSS */
#mainMenu {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom, #000033, #000066);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

#mainMenu h1 {
    color: #00ff00;
    font-size: 48px;
    margin-bottom: 40px;
    text-shadow: 0 0 10px #00ff00;
}

.menu-button {
    background: rgba(0, 100, 0, 0.3);
    color: #00ff00;
    border: 2px solid #00ff00;
    padding: 15px 30px;
    margin: 10px;
    font-size: 24px;
    cursor: pointer;
    min-width: 200px;
    transition: all 0.3s;
}

.menu-button:hover {
    background: rgba(0, 100, 0, 0.6);
    transform: scale(1.1);
}

/* Updated options menu styles */
#optionsMenu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    color: #00ff00;
    padding: 30px;
    border-radius: 10px;
    border: 2px solid #00ff00;
    display: none;
    min-width: 400px;
    z-index: 1100; /* Ensure it appears above other elements */
}

#optionsMenu h2 {
    color: #00ff00;
    text-align: center;
    margin-top: 0;
    margin-bottom: 20px;
}

.options-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 15px 0;
    font-size: 18px;
}

.difficulty-select {
    background: #004400;
    color: #00ff00;
    border: 1px solid #00ff00;
    padding: 8px 15px;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
    min-width: 120px;
}

.difficulty-select:hover {
    background: #006600;
}

#optionsMenu .menu-button {
    margin-top: 20px;
    width: 100%;
}

/* Add this to the CSS section */
#botPurchaseIndicator {
    position: fixed;
    top: 60px;
    left: 20px;
    color: #00ff00;
    font-size: 16px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px;
    border: 1px solid #00ff00;
    border-radius: 5px;
    display: none;
}
</style></head><body>
<div id="mainMenu">
    <h1>2D Space Shooter</h1>
    <button class="menu-button" onclick="startGame()">Start Game</button>
    <button class="menu-button" onclick="showOptions()">Options</button>
    <button class="menu-button" onclick="showTutorial()">How to Play</button>
    <button class="menu-button" onclick="toggleAutoPlay()">Auto Play</button>
</div>

<div id="optionsMenu">
    <h2>Game Options</h2>
    <div class="options-row">
        <span>Difficulty:</span>
        <select id="difficultySelect" class="difficulty-select">
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
        </select>
    </div>
    <div class="options-row">
        <span>Starting Lives:</span>
        <select id="livesSelect" class="difficulty-select">
            <option value="3">3</option>
            <option value="5" selected>5</option>
            <option value="7">7</option>
        </select>
    </div>
    <div class="options-row">
        <span>Starting Wave:</span>
        <select id="waveSelect" class="difficulty-select">
            <option value="1" selected>1</option>
            <option value="5">5</option>
            <option value="10">10</option>
        </select>
    </div>
    <button class="menu-button" onclick="saveOptions()">Save & Close</button>
</div>

<div id="score">Score: 0</div>
<div id="botPurchaseIndicator">Bot's Next Purchase: None</div>
<div id="health">Health: 100/100 | Lives: 5</div>
<div id="pauseMessage">GAME PAUSED</div>
<div id="controlsPanel">
    <h2>Controls</h2>
    <div class="control-row">
        <span class="key">←</span>
        <span>Move Left</span>
    </div>
    <div class="control-row">
        <span class="key">→</span>
        <span>Move Right</span>
    </div>
    <div class="control-row">
        <span class="key">SPACE</span>
        <span>Shoot</span>
    </div>
    <div class="control-row">
        <span class="key">P</span>
        <span>Pause Game</span>
    </div>
    <div class="control-row">
        <span class="key">C</span>
        <span>Toggle Controls</span>
    </div>
    <div class="control-row">
        <span class="key">H</span>
        <span>How to Play</span>
    </div>
</div>
<button id="storeButton">Store [S]</button>
<div id="storePanel">
    <h2>Store</h2>
    <div class="store-item">
        <span>Health Boost (+20)</span>
        <button onclick="buyHealth()">Cost: 50</button>
    </div>
    <div class="store-item">
        <span>Fire Rate Boost</span>
        <button onclick="buyFireRate()">Cost: 100</button>
    </div>
    <div class="store-item">
        <span>Movement Speed</span>
        <button onclick="buySpeed()">Cost: 75</button>
    </div>
    <div class="store-item">
        <span>Double Shot</span>
        <button onclick="buyDoubleShot()">Cost: 200</button>
    </div>
    <div class="store-item">
        <span>Triple Shot</span>
        <button onclick="buyTripleShot()">Cost: 300</button>
    </div>
    <div class="store-item">
        <span>Piercing Shots</span>
        <button onclick="buyPiercingShots()">Cost: 250</button>
    </div>
    <div class="store-item">
        <span>Shield (50 HP)</span>
        <button onclick="buyShield()">Cost: 150</button>
    </div>
    <div class="store-item">
        <span>Full Auto Fire</span>
        <button onclick="buyAutoFire()">Cost: 150</button>
    </div>
    <div class="store-item">
        <span>Homing Bullets</span>
        <button onclick="buyHomingBullets()">Cost: 400</button>
    </div>
    <div class="store-item teammate">
        <span>Wingman (Auto-firing teammate)</span>
        <button onclick="buyTeammate()">Cost: 500</button>
    </div>
    <div class="store-item">
        <span>Guided Missiles (Extra Damage)</span>
        <button onclick="buyMissiles()">Cost: 350</button>
    </div>
</div>
<!-- Add help panel -->
<div id="helpPanel">
    <h2>How to Play</h2>
    <div class="help-section">
        <h3>Basic Controls</h3>
        <p>Use ← → arrow keys to move left and right</p>
        <p>Press SPACE to shoot</p>
        <p>Press P to pause the game</p>
        <p>Press C to view controls</p>
        <p>Press S to open store</p>
        <p>Press H to toggle this help</p>
    </div>
    <div class="help-section">
        <h3>Game Rules</h3>
        <p>Destroy UFOs to earn points and health</p>
        <p>Watch out for falling aliens and enemy bullets</p>
        <p>Visit the store to upgrade your ship</p>
        <p>Survive as many waves as possible!</p>
    </div>
</div>

<!-- Add tips panel -->
<div id="tipsPanel">
    <h2>Gameplay Tips</h2>
    <div class="tips-section">
        <ul>
            <li>Save up points early for important upgrades</li>
            <li>The shield can protect you from multiple hits</li>
            <li>Watch out for falling aliens - they do extra damage!</li>
            <li>Piercing shots can take out multiple enemies</li>
            <li>Triple shot helps clear waves faster</li>
            <li>Kill UFOs to recover health</li>
            <li>Stay near the bottom to avoid enemy fire</li>
        </ul>
    </div>
</div>

<!-- Add try again button -->
<button id="tryAgainBtn" style="display: none;">Try Again</button>

<canvas id="gameCanvas"></canvas>

<script>
const INITIAL_MAX_HEALTH = 100;
let HEALTH_INCREASE_PER_WAVE = 20; // Change to let since we modify this in difficulty settings

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const ufoImage = new Image();
ufoImage.src = 'ufo.png';

// Add player image
const playerImage = new Image();
playerImage.src = 'player.png';

// Add falling alien image
const fallingAlienImage = new Image();
fallingAlienImage.src = 'alien falling.png';

// Add missile image
const missileImage = new Image();
missileImage.src = 'missile.png';

const player = {
    x: canvas.width / 2,
    y: canvas.height - 100,
    width: 60,
    height: 80,
    speed: 5,
    health: 100,
    maxHealth: INITIAL_MAX_HEALTH,
    score: 0,
    lives: 5  // Add lives property
};

const bullets = [];
const enemies = [];
const stars = [];
const enemyBullets = [];
const fallingAliens = [];

// Add to state variables
let teammates = [];
const TEAMMATE_COST = 500;
const MAX_TEAMMATES = 2;

let canShoot = true;
let shootCooldown = 500; // 500ms between shots
let hasDoubleShot = false; // For the store upgrade
let hasTripleShot = false;
let hasPiercingShots = false;
let hasMissiles = false; // New state variable for missiles
const MISSILE_DAMAGE = 30; // Missiles do more damage than regular bullets
const MISSILE_COOLDOWN = 2000; // Longer cooldown for missiles
let lastMissileShot = 0; // Track last missile shot time
let hasShield = false;
let shieldHealth = 0;
let isPaused = false;
let showControls = false;
let showHelp = false; // Added for help panel
let showTips = false; // Added for tips panel
let enemyDirection = 1; // 1 for right, -1 for left
let enemyStepDown = 30; // pixels to move down when reaching edge
let waveDelay = 3000; // 3 seconds between waves
let currentWave = 1;
let isWaveInProgress = false; // New variable to track wave status

// Add near the top with other state variables
const FALLING_ALIEN_CHANCE = 0.3; // 30% chance to spawn falling alien

// Update the initialization variables
let enemyColumns = 8;  // Starting number of columns
let enemyRows = 2;     // Starting number of rows (will increase with waves)
let enemySpeed = 2;    // Starting enemy speed

// Add this with other state variables (after const stars = [];)
let storeOpen = false;
let hasAutoFire = false; // Add autoFire state
let hasHomingBullets = false; // Add homing bullets state

// Add these variables for autoplay functionality
let autoPlayEnabled = false;
let lastAutoDecision = 0;
let autoDecisionInterval = 500; // Time between AI decisions in ms
let lastAutoPurchase = 0;
let autoPurchaseInterval = 5000; // Time between store checks

// Initialize stars
for (let i = 0; i < 100; i++) {
    stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 2,
        speed: 0.5 + Math.random() * 1
    });
}

function updateStars() {
    stars.forEach(star => {
        star.y += star.speed;
        if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
        }
    });
}

function drawStars() {
    ctx.fillStyle = '#ffffff';
    stars.forEach(star => {
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
    });
}

// Modify the drawBullets function
function drawBullets() {
    bullets.forEach(bullet => {
        if (bullet.isMissile) {
            ctx.save();
            // Center of missile position
            ctx.translate(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2);
            // Rotate missile based on movement direction
            ctx.rotate(bullet.angle || 0);
            ctx.drawImage(missileImage,
                -bullet.width / 2, // Center the missile
                -bullet.height / 2,
                bullet.width,
                bullet.height
            );
            ctx.restore();

            // Enhanced missile trail effect
            bullet.trailTimer = (bullet.trailTimer || 0) + 1;
            if (bullet.trailTimer % 2 === 0) {
                const trail = document.createElement('div');
                trail.className = 'missile-trail';
                trail.style.left = `${bullet.x + bullet.width / 2}px`;
                trail.style.top = `${bullet.y + bullet.height}px`;
                trail.style.width = `${bullet.width / 2}px`;
                trail.style.height = '30px';
                document.body.appendChild(trail);

                setTimeout(() => trail.remove(), 300);
            }
        } else {
            // Regular bullets
            ctx.fillStyle = bullet.homing ? '#00ffaa' : '#00ff00';
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        }
    });
}

// Update the update function
function update() {
    if (isPaused) return;

    // Update player position
    if (keys['ArrowLeft']) {
        player.x = Math.max(0, player.x - player.speed);
    }
    if (keys['ArrowRight']) {
        player.x = Math.min(canvas.width - player.width, player.x + player.speed);
    }

    // Update teammates
    teammates.forEach(teammate => {
        // Follow player with offset
        const targetX = teammate === teammates[0] ?
            player.x - 100 : // First teammate stays on left
            player.x + 100;  // Second teammate stays on right

        if (teammate.x < targetX) {
            teammate.x += player.speed;
        } else if (teammate.x > targetX) {
            teammate.x -= player.speed;
        }

        teammate.y = player.y;

        // Automatic shooting for teammates
        const now = Date.now();
        if (now - teammate.lastShot > teammate.shootCooldown) {
            bullets.push({
                x: teammate.x + teammate.width / 2,
                y: teammate.y,
                width: 4,
                height: 10,
                speed: 7,
                piercing: false,
                homing: false,
                isMissile: false
            });
            teammate.lastShot = now;
        }
    });

    // Auto-fire for player if enabled
    if (hasAutoFire && keys[' ']) {
        shoot();
    }

    // Update bullets
    bullets.forEach((bullet, index) => {
        if (bullet.speedX && bullet.speedY) {
            // For diagonal bullets (triple shot)
            bullet.x += bullet.speedX;
            bullet.y += bullet.speedY;
        } else {
            // For regular bullets
            bullet.y -= bullet.speed;
        }

        // Enhanced homing behavior
        if ((bullet.homing || bullet.isMissile) && enemies.length > 0) {
            // Find closest enemy
            let closestEnemy = null;
            let closestDist = Infinity;
            enemies.forEach(enemy => {
                const dist = Math.hypot(enemy.x - bullet.x, enemy.y - bullet.y);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestEnemy = enemy;
                }
            });

            if (closestEnemy) {
                // Calculate angle to enemy with improved precision
                const dx = closestEnemy.x - bullet.x;
                const dy = closestEnemy.y - bullet.y;
                const angle = Math.atan2(dy, dx);

                // Different homing strengths for missiles vs regular homing bullets
                const homingStrength = bullet.isMissile ? 0.3 : 0.2; // Increased from previous values
                const speedMultiplier = bullet.isMissile ? 1.5 : 1.2; // Missiles are faster

                // Calculate new velocities with increased precision
                const targetSpeedX = Math.cos(angle) * bullet.speed * speedMultiplier;
                const targetSpeedY = Math.sin(angle) * bullet.speed * speedMultiplier;

                // Initialize velocities if they don't exist
                if (!bullet.velocityX) bullet.velocityX = 0;
                if (!bullet.velocityY) bullet.velocityY = -bullet.speed;

                // Smoother velocity adjustment
                bullet.velocityX += (targetSpeedX - bullet.velocityX) * homingStrength;
                bullet.velocityY += (targetSpeedY - bullet.velocityY) * homingStrength;

                // Apply velocities with enhanced tracking
                bullet.x += bullet.velocityX;
                bullet.y += bullet.velocityY;

                // Add slight forward momentum for missiles only
                if (bullet.isMissile) {
                    // Missiles maintain more consistent upward movement
                    bullet.y -= bullet.speed * 0.1;
                }

                // Rotate missile sprite to face direction of movement
                if (bullet.isMissile) {
                    bullet.angle = Math.atan2(bullet.velocityY, bullet.velocityX) + Math.PI / 2;
                }
            } else {
                // No enemies found, maintain forward movement
                bullet.y -= bullet.speed;
            }
        }

        // Remove bullets that are off screen
        if (bullet.y < 0 || bullet.x < 0 || bullet.x > canvas.width) {
            bullets.splice(index, 1);
        }
    });

    // Update enemy bullets
    enemyBullets.forEach((bullet, index) => {
        bullet.y += bullet.speed;

        // Check collision with player
        if (collision(bullet, player)) {
            enemyBullets.splice(index, 1);

            if (hasShield && shieldHealth > 0) {
                shieldHealth = Math.max(0, shieldHealth - 10);
                if (shieldHealth <= 0) {
                    hasShield = false;
                }
            } else {
                player.health -= 10;
                updateHealthDisplay();

                if (player.health <= 0) {
                    handlePlayerDeath();
                }
            }
        }

        if (bullet.y > canvas.height) {
            enemyBullets.splice(index, 1);
        }
    });

    // Update enemies
    updateEnemies();

    // Update falling aliens
    updateFallingAliens();

    // Update stars
    updateStars();

    // Check for collisions between bullets and enemies
    enemies.forEach((enemy, enemyIndex) => {
        bullets.forEach((bullet, bulletIndex) => {
            if (collision(bullet, enemy)) {
                createExplosion(enemy.x, enemy.y);

                // Add extra damage for missiles
                const damageAmount = bullet.isMissile ? MISSILE_DAMAGE : 10;
                player.health = Math.min(player.maxHealth, player.health + damageAmount / 2);
                updateHealthDisplay();

                if (enemy.speechElement) {
                    enemy.speechElement.remove();
                }

                enemies.splice(enemyIndex, 1);
                if (!bullet.piercing) {
                    bullets.splice(bulletIndex, 1);
                }
                player.score += damageAmount;
                document.getElementById('score').textContent = `Score: ${player.score}`;

                // Random chance to spawn falling alien
                if (Math.random() < FALLING_ALIEN_CHANCE) {
                    fallingAliens.push({
                        x: enemy.x,
                        y: enemy.y,
                        width: 40,
                        height: 40,
                        speed: 3
                    });
                }
            }
        });
    });
}

function drawPlayer() {
    // Draw player ship using player image
    ctx.save();
    ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
    ctx.restore();

    // Draw shield if active
    if (hasShield && shieldHealth > 0) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(0, 255, 0, ${shieldHealth / 50})`;
        ctx.lineWidth = 3;
        ctx.arc(player.x + player.width / 2, player.y + player.height / 2,
            Math.max(player.width, player.height) / 1.5, 0, Math.PI * 2);
        ctx.stroke();
    }
}

function drawTeammates() {
    teammates.forEach((teammate, index) => {
        // Draw teammate ships slightly smaller than player
        ctx.save();
        ctx.drawImage(playerImage, teammate.x, teammate.y, teammate.width, teammate.height);
        ctx.restore();

        // Draw indicator text above teammate
        const indicatorText = `Wingman ${index + 1}`;
        const indicator = document.querySelector(`.teammate-indicator-${index}`);
        if (!indicator) {
            const newIndicator = document.createElement('div');
            newIndicator.className = `teammate-indicator teammate-indicator-${index}`;
            document.body.appendChild(newIndicator);
        }
        const existingIndicator = document.querySelector(`.teammate-indicator-${index}`);
        existingIndicator.style.left = `${teammate.x + teammate.width / 2}px`;
        existingIndicator.style.top = `${teammate.y - 20}px`;
        existingIndicator.textContent = indicatorText;
    });
}

function drawEnemyBullets() {
    ctx.fillStyle = '#ff0000';
    enemyBullets.forEach(bullet => {
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
    });
}

function drawEnemies() {
    enemies.forEach(enemy => {
        ctx.drawImage(ufoImage, enemy.x, enemy.y, enemy.width, enemy.height);
    });
}

// Add explosion effect function
function createExplosion(x, y) {
    const explosion = document.createElement('div');
    explosion.className = 'explosion';
    explosion.style.left = `${x}px`;
    explosion.style.top = `${y}px`;
    explosion.innerHTML = '💥';
    document.body.appendChild(explosion);

    // Remove explosion element after animation
    setTimeout(() => explosion.remove(), 500);
}

// Add this function after the updateEnemies function and before the update function
function updateFallingAliens() {
    fallingAliens.forEach((alien, index) => {
        alien.y += alien.speed;

        // Remove if off screen
        if (alien.y > canvas.height) {
            fallingAliens.splice(index, 1);
            return;
        }

        // Check collision with player
        if (collision(alien, player)) {
            fallingAliens.splice(index, 1);
            // Extra damage from falling aliens
            if (hasShield && shieldHealth > 0) {
                shieldHealth = Math.max(0, shieldHealth - 30);
                if (shieldHealth <= 0) {
                    hasShield = false;
                }
            } else {
                player.health -= 30; // More damage than regular UFOs
                updateHealthDisplay();
            }

            if (player.health <= 0) {
                handlePlayerDeath();
            }
        }
    });
}

// Modify the updateEnemies function
function updateEnemies() {
    if (enemies.length === 0) {
        if (!isWaveInProgress) {
            currentWave++;
            setTimeout(initializeEnemies, waveDelay);
            isWaveInProgress = true; // Set flag when starting new wave
        }
        return;
    }

    // Move enemies Space Invaders style
    let touchedEdge = false;

    enemies.forEach(enemy => {
        enemy.x += enemy.speed * enemyDirection;

        // Check if any enemy touches the edges
        if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
            touchedEdge = true;
        }

        // Use enemy's individual shoot chance
        if (Math.random() < enemy.shootChance) {
            enemyBullets.push({
                x: enemy.x + enemy.width / 2,
                y: enemy.y + enemy.height,
                width: 4,
                height: 10,
                speed: 5 + (currentWave * 0.5) // Bullets get faster too
            });
        }
    });

    // If any enemy touched edge, move all enemies down and reverse direction
    if (touchedEdge) {
        enemies.forEach(enemy => {
            enemy.y += enemyStepDown;
        });
        enemyDirection *= -1;

        // Check if enemies reached the bottom
        let enemyReachedBottom = enemies.some(enemy => enemy.y + enemy.height > canvas.height - 100);
        if (enemyReachedBottom) {
            // Deal 50 damage to player
            if (hasShield && shieldHealth > 0) {
                shieldHealth = Math.max(0, shieldHealth - 50);
                if (shieldHealth <= 0) {
                    hasShield = false;
                }
            } else {
                player.health -= 50;
                updateHealthDisplay();
            }

            // Move enemies back to top
            let minY = 50;
            enemies.forEach(enemy => {
                enemy.y = minY + (enemy.y % enemyStepDown);
            });

            // Check for player death
            if (player.health <= 0) {
                handlePlayerDeath();
            }
        }
    }
}

function initializeEnemies() {
    isWaveInProgress = true;

    // Increase max health with each wave
    player.maxHealth = INITIAL_MAX_HEALTH + ((currentWave - 1) * HEALTH_INCREASE_PER_WAVE);
    // Heal player to full when starting new wave
    player.health = player.maxHealth;
    updateHealthDisplay();

    // Scale difficulty with waves
    enemySpeed = 2 + (currentWave * 0.5); // Increase speed
    enemyRows = Math.min(6, 2 + Math.floor(currentWave / 2)); // Add more rows up to max of 6
    enemyColumns = Math.min(12, 8 + Math.floor(currentWave / 3)); // Add more columns up to max of 12

    const startX = (canvas.width - (enemyColumns * 100)) / 2;
    const startY = 50;

    // Clear existing enemies and their speech bubbles
    enemies.forEach(enemy => {
        if (enemy.speechElement) {
            enemy.speechElement.remove();
        }
    });
    enemies.length = 0;

    // Create wave message
    const waveMessage = document.createElement('div');
    waveMessage.className = 'wave-message';
    waveMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #00ff00;
        font-size: 48px;
        font-family: Arial, sans-serif;
        text-align: center;
    `;
    waveMessage.textContent = `Wave ${currentWave}`;
    document.body.appendChild(waveMessage);

    // Remove wave message after 2 seconds
    setTimeout(() => waveMessage.remove(), 2000);

    // Create enemies for this wave
    for (let row = 0; row < enemyRows; row++) {
        for (let col = 0; col < enemyColumns; col++) {
            enemies.push({
                x: startX + col * 100,
                y: startY + row * 100,
                width: 80,
                height: 80,
                speed: enemySpeed,
                originalX: startX + col * 100,
                lastSpoke: 0,
                lastShot: 0,
                speaking: false,
                currentPhrase: "",
                speechElement: null,
                shootChance: 0.002 + (currentWave * 0.0005) // Increase shoot frequency with waves
            });
        }
    }

    // Reduce wave delay for higher waves
    waveDelay = Math.max(1000, 3000 - (currentWave * 200));

    setTimeout(() => {
        isWaveInProgress = false;
    }, 100);
}

// Add this function near the other utility functions
function updateHealthDisplay() {
    document.getElementById('health').textContent =
        `Health: ${player.health}/${player.maxHealth} | Lives: ${player.lives}`;
}

// Add this function near the other utility functions
function collision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
}

// Add this function after the collision function and before the controls section
function handlePlayerDeath() {
    player.lives--;
    updateHealthDisplay();

    if (player.lives <= 0) {
        // Game Over
        isPaused = true;
        document.getElementById('pauseMessage').textContent = 'GAME OVER';
        document.getElementById('pauseMessage').style.display = 'block';
        document.getElementById('tryAgainBtn').style.display = 'block';

        // Clean up any active enemies' speech bubbles
        enemies.forEach(enemy => {
            if (enemy.speechElement) {
                enemy.speechElement.remove();
            }
        });

        // Clear teammates' indicators
        teammates.forEach((teammate, index) => {
            const indicator = document.querySelector(`.teammate-indicator-${index}`);
            if (indicator) {
                indicator.remove();
            }
        });
    } else {
        // Reset player for next life
        player.health = player.maxHealth;
        // Create temporary invulnerability
        player.invulnerable = true;
        setTimeout(() => {
            player.invulnerable = false;
        }, 2000); // 2 seconds of invulnerability

        // Flash player to show invulnerability
        let flashCount = 0;
        const flashInterval = setInterval(() => {
            if (flashCount >= 8) { // Flash 4 times (8 state changes)
                clearInterval(flashInterval);
                return;
            }
            player.visible = !player.visible;
            flashCount++;
        }, 250); // Toggle visibility every 250ms
    }
}

// Controls
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (e.key === 'p' || e.key === 'P') {
        togglePause();
    }
    if (e.key === 'c' || e.key === 'C') {
        toggleControls();
    }
    if (e.key === 's' || e.key === 'S') {
        toggleStore();
    }
    if (e.key === 'h' || e.key === 'H') {
        toggleHelp();
    }
    if (e.key === 't' || e.key === 'T') {
        toggleTips();
    }
    if (e.key === ' ' && hasAutoFire) { // Enable auto-fire on space
        shoot();
    }
});
document.addEventListener('keyup', (e) => keys[e.key] = false);
document.addEventListener('keypress', (e) => {
    if (e.key === ' ' && !isPaused && !hasAutoFire) {
        shoot();
    }
});

function toggleControls() {
    showControls = !showControls;
    document.getElementById('controlsPanel').style.display = showControls ? 'block' : 'none';
}

function togglePause() {
    isPaused = !isPaused;
    // Only show "GAME PAUSED" if player is still alive
    if (isPaused && player.health > 0) {
        document.getElementById('pauseMessage').textContent = 'GAME PAUSED';
        document.getElementById('pauseMessage').style.display = 'block';
    } else {
        document.getElementById('pauseMessage').style.display = 'none';
    }
}

function toggleStore() {
    storeOpen = !storeOpen;
    isPaused = storeOpen; // Pause game while store is open
    document.getElementById('storePanel').style.display = storeOpen ? 'block' : 'none';
    document.getElementById('pauseMessage').style.display = 'none';
}

function toggleHelp() {
    showHelp = !showHelp;
    isPaused = showHelp; // Pause game while help is open
    document.getElementById('helpPanel').style.display = showHelp ? 'block' : 'none';
    document.getElementById('pauseMessage').style.display = 'none';
}

function toggleTips() {
    showTips = !showTips;
    isPaused = showTips; // Pause game while tips are open
    document.getElementById('tipsPanel').style.display = showTips ? 'block' : 'none';
    document.getElementById('pauseMessage').style.display = 'none';
}

// Move this function up near other menu functions, just after the toggleTips function:
function showOptions() {
    document.getElementById('optionsMenu').style.display = 'block';
}

function showTutorial() {
    // Show help panel when tutorial button is clicked
    toggleHelp();
}

// Add store purchase function for homing bullets
function buyHomingBullets() {
    if (player.score >= 400 && !hasHomingBullets) {
        player.score -= 400;
        hasHomingBullets = true;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

// Add store purchase function for auto-fire
function buyAutoFire() {
    if (player.score >= 150 && !hasAutoFire) {
        player.score -= 150;
        hasAutoFire = true;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

// Add store purchase function for teammates
function buyTeammate() {
    if (player.score >= TEAMMATE_COST && teammates.length < MAX_TEAMMATES) {
        player.score -= TEAMMATE_COST;

        // Create new teammate
        const teammate = {
            x: player.x + (teammates.length === 0 ? -100 : 100),
            y: player.y,
            width: 40,
            height: 60,
            active: true,
            lastShot: 0,
            shootCooldown: 1000
        };

        teammates.push(teammate);
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

// Add these functions after the buyAutoFire function and before the shoot function:
function buyHealth() {
    if (player.score >= 50) {
        player.score -= 50;
        player.health = Math.min(player.maxHealth, player.health + 20);
        updateHealthDisplay();
    }
}

function buyFireRate() {
    if (player.score >= 100) {
        player.score -= 100;
        shootCooldown = Math.max(100, shootCooldown - 100);
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

function buySpeed() {
    if (player.score >= 75) {
        player.score -= 75;
        player.speed += 1;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

function buyDoubleShot() {
    if (player.score >= 200 && !hasDoubleShot) {
        player.score -= 200;
        hasDoubleShot = true;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

function buyTripleShot() {
    if (player.score >= 300 && !hasTripleShot) {
        player.score -= 300;
        hasTripleShot = true;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

function buyPiercingShots() {
    if (player.score >= 250 && !hasPiercingShots) {
        player.score -= 250;
        hasPiercingShots = true;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

function buyShield() {
    if (player.score >= 150) {
        player.score -= 150;
        hasShield = true;
        shieldHealth = 50;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

// Add store purchase function for missiles
function buyMissiles() {
    if (player.score >= 350 && !hasMissiles) {
        player.score -= 350;
        hasMissiles = true;
        document.getElementById('score').textContent = `Score: ${player.score}`;
    }
}

// Replace the shoot function with this updated version
function shoot() {
    if (!canShoot || isPaused) return;

    const now = Date.now();

    // Define bullet properties
    const bulletProps = {
        width: 4,
        height: 10,
        speed: 7,
        piercing: hasPiercingShots,
        homing: hasHomingBullets,
        isMissile: false
    };

    // Center bullet for all shot types
    bullets.push({
        ...bulletProps,
        x: player.x + player.width / 2 - bulletProps.width / 2,
        y: player.y
    });

    // Add side bullets for double shot
    if (hasDoubleShot) {
        bullets.push({
            ...bulletProps,
            x: player.x + player.width / 4 - bulletProps.width / 2,  // Left bullet
            y: player.y
        });
        bullets.push({
            ...bulletProps,
            x: player.x + (player.width * 3 / 4) - bulletProps.width / 2,  // Right bullet
            y: player.y
        });
    }

    // Add diagonal bullets for triple shot
    if (hasTripleShot) {
        bullets.push({
            ...bulletProps,
            x: player.x + player.width / 4 - bulletProps.width / 2,  // Left diagonal
            y: player.y,
            speedX: -2,  // Add horizontal movement
            speedY: -7   // Vertical movement
        });
        bullets.push({
            ...bulletProps,
            x: player.x + (player.width * 3 / 4) - bulletProps.width / 2,  // Right diagonal
            y: player.y,
            speedX: 2,   // Add horizontal movement
            speedY: -7   // Vertical movement
        });
    }

    // Add missiles if player has them and cooldown is ready
    if (hasMissiles && now - lastMissileShot > MISSILE_COOLDOWN) {
        bullets.push({
            x: player.x + 10,
            y: player.y,
            width: 12,  // Increased size
            height: 24, // Increased size
            speed: 5,
            piercing: true,
            homing: true,
            isMissile: true,
            trailTimer: 0
        });

        bullets.push({
            x: player.x + player.width - 20,
            y: player.y,
            width: 12,  // Increased size
            height: 24, // Increased size
            speed: 5,
            piercing: true,
            homing: true,
            isMissile: true,
            trailTimer: 0
        });

        lastMissileShot = now;
    }

    canShoot = false;
    setTimeout(() => {
        canShoot = true;
    }, shootCooldown);
}

// Add AI decision making function
function makeAutoDecisions() {
    if (!autoPlayEnabled || isPaused) return;

    const now = Date.now();
    if (now - lastAutoDecision < autoDecisionInterval) return;

    // Find closest enemy
    let closestEnemy = null;
    let closestDist = Infinity;
    enemies.forEach(enemy => {
        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (dist < closestDist) {
            closestDist = dist;
            closestEnemy = enemy;
        }
    });

    // Dodge enemy bullets
    const nearbyBullets = enemyBullets.filter(bullet => {
        return Math.abs(bullet.x - player.x) < 100 && bullet.y > player.y - 200;
    });

    if (nearbyBullets.length > 0) {
        // Dodge!
        const avgBulletX = nearbyBullets.reduce((sum, b) => sum + b.x, 0) / nearbyBullets.length;
        if (avgBulletX < player.x) {
            keys['ArrowRight'] = true;
            keys['ArrowLeft'] = false;
        } else {
            keys['ArrowLeft'] = true;
            keys['ArrowRight'] = false;
        }
    } else if (closestEnemy) {
        // Move to shoot enemies
        const targetX = closestEnemy.x;
        if (Math.abs(player.x - targetX) > 10) {
            if (player.x < targetX) {
                keys['ArrowRight'] = true;
                keys['ArrowLeft'] = false;
            } else {
                keys['ArrowLeft'] = true;
                keys['ArrowRight'] = false;
            }
        }
    }

    // Auto shoot - directly call shoot() instead of using space key
    if (closestEnemy) {
        shoot();
    }

    // Auto purchase upgrades
    if (now - lastAutoPurchase > autoPurchaseInterval) {
        autoPurchase();
        lastAutoPurchase = now;
    }

    lastAutoDecision = now;
}

// Add to gameLoop function
function gameLoop() {
    if (!gameStarted) return;

    if (autoPlayEnabled) {
        makeAutoDecisions();
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawStars();
    drawPlayer(); // Call drawPlayer function
    drawTeammates(); // Call drawTeammates function
    drawBullets(); // Call drawBullets function
    drawEnemyBullets(); // Call drawEnemyBullets function
    drawEnemies(); // Call drawEnemies function
    update();

    requestAnimationFrame(gameLoop);
}

// Handle window resize
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    player.x = canvas.width / 2;
    player.y = canvas.height - 100;

    // Remove all speech bubbles
    enemies.forEach(enemy => {
        if (enemy.speechElement) {
            enemy.speechElement.remove();
            enemy.speechElement = null;
            enemy.speaking = false;
        }
    });
});

// Add this function to the script
function toggleAutoPlay() {
    autoPlayEnabled = !autoPlayEnabled;
    if (autoPlayEnabled && !gameStarted) {
        startGame();
    }
    // Show/hide the purchase indicator based on auto play state
    document.getElementById('botPurchaseIndicator').style.display =
        autoPlayEnabled ? 'block' : 'none';
}

// Modify the startGame function
function startGame() {
    gameStarted = true;
    document.getElementById('mainMenu').style.display = 'none';

    // Apply difficulty settings
    if (gameDifficulty === 'easy') {
        HEALTH_INCREASE_PER_WAVE = 30;
        player.maxHealth = 150;
        player.health = 150;
        player.lives = 7;  // More lives on easy
        shootCooldown = 400;
    } else if (gameDifficulty === 'hard') {
        HEALTH_INCREASE_PER_WAVE = 10;
        player.maxHealth = 80;
        player.health = 80;
        player.lives = 3;  // Fewer lives on hard
        shootCooldown = 600;
    } else {
        // Normal difficulty
        player.lives = 5;
    }

    // Apply starting lives from options
    player.lives = parseInt(document.getElementById('livesSelect').value);
    player.health = player.maxHealth;
    currentWave = startingWave;

    // Update display
    updateHealthDisplay();

    // Start the game
    initializeEnemies();
    gameLoop();
}

// Update the health display whenever it changes
// Replace all instances of:
updateHealthDisplay();
// With:
// updateHealthDisplay();

// Add to the try again button click handler in handlePlayerDeath
document.getElementById('tryAgainBtn').onclick = () => {
    // Reset game state
    player.health = player.maxHealth;
    player.lives = parseInt(document.getElementById('livesSelect').value);  // Reset lives
    player.score = 0;
    currentWave = startingWave;
    enemies.length = 0;
    bullets.length = 0;
    enemyBullets.length = 0;
    fallingAliens.length = 0;

    // Reset upgrades
    hasDoubleShot = false;
    hasTripleShot = false;
    hasPiercingShots = false;
    hasShield = false;
    shieldHealth = 0;
    hasAutoFire = false;
    hasHomingBullets = false;
    hasMissiles = false; // Reset missiles
    shootCooldown = 500;
    player.speed = 5;

    // Reset teammates
    teammates.forEach(teammate => {
        if (teammate.indicator) {
            teammate.indicator.remove();
        }
    });
    teammates = [];

    // Hide game over elements
    document.getElementById('pauseMessage').style.display = 'none';
    document.getElementById('tryAgainBtn').style.display = 'none';

    // Show main menu
    document.getElementById('mainMenu').style.display = 'flex';

    // Update UI
    document.getElementById('score').textContent = 'Score: 0';
    updateHealthDisplay();

    isPaused = false;
};

// Modify the gameLoop function
function gameLoop() {
    if (!gameStarted) return;

    if (autoPlayEnabled) {
        makeAutoDecisions();
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawStars();
    drawPlayer(); // Call drawPlayer function
    drawTeammates(); // Call drawTeammates function
    drawBullets(); // Call drawBullets function
    drawEnemyBullets(); // Call drawEnemyBullets function
    drawEnemies(); // Call drawEnemies function
    update();

    requestAnimationFrame(gameLoop);
}

// Handle window resize
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    player.x = canvas.width / 2;
    player.y = canvas.height - 100;

    // Remove all speech bubbles
    enemies.forEach(enemy => {
        if (enemy.speechElement) {
            enemy.speechElement.remove();
            enemy.speechElement = null;
            enemy.speaking = false;
        }
    });
});

let gameStarted = false;
let gameDifficulty = 'normal';
let startingLives = 5;
let startingWave = 1;

// Add these functions to the script
function saveOptions() {
    gameDifficulty = document.getElementById('difficultySelect').value;
    startingLives = parseInt(document.getElementById('livesSelect').value);
    startingWave = parseInt(document.getElementById('waveSelect').value);
    document.getElementById('optionsMenu').style.display = 'none';

    // Add feedback to show options were saved
    const feedback = document.createElement('div');
    feedback.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 255, 0, 0.2);
        color: #00ff00;
        padding: 10px 20px;
        border-radius: 5px;
        border: 1px solid #00ff00;
    `;
    feedback.textContent = 'Options saved!';
    document.body.appendChild(feedback);

    // Remove feedback after 2 seconds
    setTimeout(() => feedback.remove(), 2000);
}
</script>
</body></html>
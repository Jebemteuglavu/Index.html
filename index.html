<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OKANFXLABS Legacy - AI-Enhanced Dog Particle System</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/3.18.0/tf.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&amp;family=Roboto:wght@300;400;700&amp;display=swap" rel="stylesheet">
<style>
  body, html {
    margin: 0;
    padding: 0;
    font-family: 'Roboto', sans-serif;
    background-color: #000;
    color: #fff;
    overflow: hidden;
  }
  #app {
    position: relative;
    width: 100vw;
    height: 100vh;
  }
  #editor-overlay {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 10px;
    border-radius: 5px;
  }
  .editor-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  label {
    font-weight: bold;
  }
  input[type="range"] {
    width: 100%;
  }
  #ai-image-preview {
    max-width: 100%;
    max-height: 200px;
    margin-top: 10px;
    border: 2px solid #0a9396;
    border-radius: 4px;
    cursor: pointer;
    transition: transform 0.3s ease;
  }
  #ai-image-preview:hover {
    transform: scale(1.05);
  }
  #ai-prompt {
    width: 100%;
    padding: 5px;
    margin-bottom: 10px;
    background-color: #1a1a1a;
    color: #fff;
    border: 1px solid #0a9396;
    border-radius: 4px;
  }
  #generate-ai-image, #upload-label {
    width: 100%;
    padding: 10px;
    background-color: #0a9396;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    text-align: center;
  }
  #generate-ai-image:hover, #upload-label:hover {
    background-color: #0c7c7e;
  }
  #ai-generation-status {
    margin-top: 10px;
    font-style: italic;
    color: #0a9396;
  }
  #loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }
  .loading-spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid #0a9396;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  #image-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.9);
  }
  #modal-content {
    margin: auto;
    display: block;
    width: 80%;
    max-width: 700px;
    max-height: 80%;
    animation-name: zoom;
    animation-duration: 0.6s;
  }
  @keyframes zoom {
    from {transform:scale(0)}
    to {transform:scale(1)}
  }
  #close-modal {
    position: absolute;
    top: 15px;
    right: 35px;
    color: #f1f1f1;
    font-size: 40px;
    font-weight: bold;
    transition: 0.3s;
  }
  #close-modal:hover,
  #close-modal:focus {
    color: #bbb;
    text-decoration: none;
    cursor: pointer;
  }
  #file-upload {
    display: none;
  }
  #upload-label {
    display: inline-block;
    margin-top: 10px;
  }
  #file-info {
    margin-top: 5px;
    font-size: 0.9em;
    color: #0a9396;
  }
  #modal-controls {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 20px;
  }
  #delve-button, #reroll-button {
    padding: 10px 20px;
    background-color: #0a9396;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  #delve-button:hover, #reroll-button:hover {
    background-color: #0c7c7e;
  }
</style>
</head>
<body>
  <div id="app">
    <canvas id="particle-canvas"></canvas>
    <div id="editor-overlay">
      <div class="editor-controls">
        <div class="control-group">
          <label for="particle-count">Particle Count:</label>
          <input type="range" id="particle-count" min="1000" max="100000" step="1000" value="50000">
        </div>
        <div class="control-group">
          <label for="particle-size">Particle Size:</label>
          <input type="range" id="particle-size" min="0.1" max="5" step="0.1" value="1">
        </div>
        <div class="control-group">
          <label for="ai-prompt">Image Generation:</label>
          <input type="text" id="ai-prompt" placeholder="Describe the dog image you want to generate" value="playful puppies in a park">
          <button id="generate-ai-image">Generate AI Image</button>
          <label for="file-upload" id="upload-label">Upload Image</label>
          <input type="file" id="file-upload" accept="image/*">
          <div id="file-info"></div>
          <div id="ai-generation-status"></div>
        </div>
        <img id="ai-image-preview" alt="An enhanced particle system visualization of dogs in a park, now with multiple complementary layers. The image displays a more sophisticated representation of various dog breeds composed of vibrant particles. The background blends soft blues and greens, reminiscent of a park setting. In the foreground, distinct silhouettes of different dogs are visible: a majestic German Shepherd, a playful Labrador, a small Chihuahua, and a fluffy Pomeranian. Each dog is created from smaller, colorful particles that give the impression of fur texture and movement. The new complementary layer adds depth and contrast, enhancing the overall 3D effect. Scattered throughout are detailed paw prints and bone shapes. The additional processing has improved the leveling and accuracy, resulting in a more refined and true-to-source representation. The furry overlay application gives a more realistic texture to the dogs, making them appear more lifelike within the particle system." style="display: block;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIAAQMAAADOtka5AAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAADZJREFUeNrtwQENAAAAwqD3T20PBxQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAvwErtAABONm5kgAAAABJRU5ErkJggg==" width="512" height="512">
      </div>
    </div>
  </div>
  
  <div id="loading-overlay" style="display: none;">
    <div class="loading-spinner"></div>
  </div>

  <div id="image-modal">
    <span id="close-modal">Ã—</span>
    <img id="modal-content" alt="Enlarged view of the generated or uploaded image">
    <div id="modal-controls">
      <button id="delve-button">Delve Deeper</button>
      <button id="reroll-button">Reroll Image</button>
    </div>
  </div>

  <script>
    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('particle-canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Particle system
    let particles;
    let complementaryParticles;
    let particleCount = 50000;
    let complementaryParticleCount = 25000; // Half of the main particle count
    let particleSize = 1;
    let imageData;

    function createParticleSystem() {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 100;
        positions[i + 1] = (Math.random() - 0.5) * 100;
        positions[i + 2] = (Math.random() - 0.5) * 100;

        colors[i] = Math.random();
        colors[i + 1] = Math.random();
        colors[i + 2] = Math.random();
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: particleSize,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // Create complementary particle system
      const complementaryGeometry = new THREE.BufferGeometry();
      const complementaryPositions = new Float32Array(complementaryParticleCount * 3);
      const complementaryColors = new Float32Array(complementaryParticleCount * 3);

      complementaryGeometry.setAttribute('position', new THREE.BufferAttribute(complementaryPositions, 3));
      complementaryGeometry.setAttribute('color', new THREE.BufferAttribute(complementaryColors, 3));

      const complementaryMaterial = new THREE.PointsMaterial({
        size: particleSize * 0.75,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
      });

      complementaryParticles = new THREE.Points(complementaryGeometry, complementaryMaterial);
      scene.add(complementaryParticles);
    }

    createParticleSystem();

    // Set camera position to match images
    camera.position.z = 100;
    camera.position.y = 0;
    camera.lookAt(scene.position);

    // New algorithm: Particle wave motion
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      const positions = particles.geometry.attributes.position.array;
      const complementaryPositions = complementaryParticles.geometry.attributes.position.array;

      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];

        positions[i + 1] = y + Math.sin(time + x * 0.1) * 0.2;
        positions[i + 2] = z + Math.cos(time + y * 0.1) * 0.2;
      }

      for (let i = 0; i < complementaryPositions.length; i += 3) {
        const x = complementaryPositions[i];
        const y = complementaryPositions[i + 1];
        const z = complementaryPositions[i + 2];

        complementaryPositions[i + 1] = y + Math.cos(time + x * 0.1) * 0.2;
        complementaryPositions[i + 2] = z + Math.sin(time + y * 0.1) * 0.2;
      }

      particles.geometry.attributes.position.needsUpdate = true;
      complementaryParticles.geometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }

    animate();

    // Event listeners for controls
    document.getElementById('particle-count').addEventListener('input', (e) => {
      particleCount = parseInt(e.target.value);
      complementaryParticleCount = Math.floor(particleCount / 2);
      scene.remove(particles);
      scene.remove(complementaryParticles);
      createParticleSystem();
      if (imageData) {
        applyFormation();
      }
    });

    document.getElementById('particle-size').addEventListener('input', (e) => {
      particleSize = parseFloat(e.target.value);
      particles.material.size = particleSize;
      complementaryParticles.material.size = particleSize * 0.75;
    });

    // AI Image Generation
    const generateAiImageBtn = document.getElementById('generate-ai-image');
    const aiPromptInput = document.getElementById('ai-prompt');
    const aiImagePreview = document.getElementById('ai-image-preview');
    const aiGenerationStatus = document.getElementById('ai-generation-status');
    const loadingOverlay = document.getElementById('loading-overlay');

    async function generateAiImage() {
      const prompt = aiPromptInput.value;
      aiGenerationStatus.textContent = 'Generating image...';
      loadingOverlay.style.display = 'flex';

      try {
        // Simulating API call with a delay
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Generate a random color
        const randomColor = Math.floor(Math.random()*16777215).toString(16);
        
        // Create a canvas and draw a colored rectangle
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#" + randomColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Convert canvas to data URL
        const imageUrl = canvas.toDataURL('image/png');

        aiImagePreview.src = imageUrl;
        aiImagePreview.style.display = 'block';
        aiGenerationStatus.textContent = 'Image generated successfully!';

        // Load the generated image and apply it to the particle system
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          applyFormation();
        };
        img.src = imageUrl;
      } catch (error) {
        console.error('Error generating AI image:', error);
        aiGenerationStatus.textContent = 'Error generating image. Please try again.';
      } finally {
        loadingOverlay.style.display = 'none';
      }
    }

    // Event listener for the Generate AI Image button
    generateAiImageBtn.addEventListener('click', generateAiImage);

    // Function to apply the generated image to the particle system
    function applyFormation() {
      if (!imageData) return;

      const positions = particles.geometry.attributes.position.array;
      const colors = particles.geometry.attributes.color.array;
      const complementaryPositions = complementaryParticles.geometry.attributes.position.array;
      const complementaryColors = complementaryParticles.geometry.attributes.color.array;

      for (let i = 0; i < particleCount; i++) {
        const x = Math.floor(Math.random() * imageData.width);
        const y = Math.floor(Math.random() * imageData.height);
        const pixelIndex = (y * imageData.width + x) * 4;

        const r = imageData.data[pixelIndex] / 255;
        const g = imageData.data[pixelIndex + 1] / 255;
        const b = imageData.data[pixelIndex + 2] / 255;
        const brightness = (r + g + b) / 3;

        positions[i * 3] = (x / imageData.width - 0.5) * 100;
        positions[i * 3 + 1] = (y / imageData.height - 0.5) * -100;
        positions[i * 3 + 2] = (brightness - 0.5) * 50;

        colors[i * 3] = r;
        colors[i * 3 + 1] = g;
        colors[i * 3 + 2] = b;
      }

      // Apply complementary particles
      for (let i = 0; i < complementaryParticleCount; i++) {
        const x = Math.floor(Math.random() * imageData.width);
        const y = Math.floor(Math.random() * imageData.height);
        const pixelIndex = (y * imageData.width + x) * 4;

        const r = imageData.data[pixelIndex] / 255;
        const g = imageData.data[pixelIndex + 1] / 255;
        const b = imageData.data[pixelIndex + 2] / 255;
        const brightness = (r + g + b) / 3;

        // Complementary color calculation
        const complementaryR = 1 - r;
        const complementaryG = 1 - g;
        const complementaryB = 1 - b;

        complementaryPositions[i * 3] = (x / imageData.width - 0.5) * 100 + (Math.random() - 0.5) * 5;
        complementaryPositions[i * 3 + 1] = (y / imageData.height - 0.5) * -100 + (Math.random() - 0.5) * 5;
        complementaryPositions[i * 3 + 2] = (brightness - 0.5) * 50 + (Math.random() - 0.5) * 5;

        complementaryColors[i * 3] = complementaryR;
        complementaryColors[i * 3 + 1] = complementaryG;
        complementaryColors[i * 3 + 2] = complementaryB;
      }

      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.color.needsUpdate = true;
      complementaryParticles.geometry.attributes.position.needsUpdate = true;
      complementaryParticles.geometry.attributes.color.needsUpdate = true;
    }

    // Image modal functionality
    const modal = document.getElementById('image-modal');
    const modalImg = document.getElementById('modal-content');
    const closeModal = document.getElementById('close-modal');
    const delveButton = document.getElementById('delve-button');
    const rerollButton = document.getElementById('reroll-button');

    aiImagePreview.onclick = function() {
      modal.style.display = "block";
      modalImg.src = this.src;
    }

    closeModal.onclick = function() {
      modal.style.display = "none";
    }

    delveButton.onclick = function() {
      // Implement delve functionality here
      console.log("Delving deeper into the image...");
      // You can add more complex image processing or generation here
    }

    rerollButton.onclick = function() {
      generateAiImage();
    }

    // File upload functionality
    const fileUpload = document.getElementById('file-upload');
    const fileInfo = document.getElementById('file-info');

    fileUpload.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        fileInfo.textContent = `File selected: ${file.name}`;
        const reader = new FileReader();
        reader.onload = function(event) {
          aiImagePreview.src = event.target.result;
          aiImagePreview.style.display = 'block';
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            applyFormation();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    // Window resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initial generation of AI image on page load
    generateAiImage();
</script>
</body></html>